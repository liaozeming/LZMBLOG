---
title: 算法总结
date: 2024/06/26
tags:
- 秋招
hideComments:   true 
---
# 算法

write by lzm 

email  liaozeming@smail.nju.edu.cn  

学习地址 https://programmercarl.com/

## 经典排序算法

### 冒泡排序

```java
private void sort(int[] temp) {
        int length = temp.length;
        for (int i = 1; i < length; i++) {
            for (int j = 1; j < length - i + 1; j++) {
                if (temp[j] < temp[j - 1]) {
                    int pre = temp[j - 1];
                    temp[j - 1] = temp[j];
                    temp[j] = pre;
                }
            }
        }
    }
```

### 快速排序

```java
public static void quickSort(int[] array, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(array, low, high);
        quickSort(array, low, pivotIndex); // 注意这里是 `pivotIndex`
        quickSort(array, pivotIndex + 1, high);
    }
}

private static int partition(int[] array, int low, int high) {
    int pivot = array[low]; // 选择第一个元素作为枢轴
    int left = low; // `left` 初始化为 `low`
    int right = high; // `right` 初始化为 `high`

    while (true) {
        // 使用 `while` 循环移动 `left`，找到不小于枢轴的元素
        while (left <= right && array[left] < pivot) {
            left++;
        }

        // 使用 `while` 循环移动 `right`，找到不大于枢轴的元素
        while (left <= right && array[right] > pivot) {
            right--;
        }

        // 当左右指针相遇时，返回 `right` 作为分区点
        if (left >= right) {
            return right;
        }

        // 交换 `left` 和 `right` 指向的元素
        int temp = array[left];
        array[left] = array[right];
        array[right] = temp;

        // 移动指针以继续分区
        left++;
        right--;
    }
}
```

### 堆排序

```java
public static void heapSort(int[] arr) {
    //1.构建初始堆，arr[0]为最大元素
    buildMaxHeap(arr);
    // 注意这里是i>1 只有三个元素时----最后一次执行
    for (int i = arr.length - 1; i >= 1; i--) {
        swap(arr, 0, i);
        adjustHeap(arr, 0, i);
    }
}


/**
     * 构建最大堆，arr[0] 是最大值
     *
     * @param arr
     */
public static void buildMaxHeap(int[] arr) {
    for (int i = (arr.length - 1 - 1) / 2; i >= 0; i--) {
        adjustHeap(arr, i, arr.length);
    }
}

/**
     * 调整堆，k 父节点的编号 length: 需要调整的数组的范围的长度从1到length
     *
     * @param arr
     * @param i
     * @param length
     */
public static void adjustHeap(int[] arr, int i, int length) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;
    if (left < length && arr[left] > arr[i]) {
        largest = left;
    }
    if (right < length && arr[right] > arr[largest]) {
        largest = right;
    }
    if (largest != i) {
        swap(arr, i, largest);
        adjustHeap(arr, largest, length);
    }

}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### 插入排序

```java
private void sort(int[] array) {
    for (int i = 1; i < array.length; i++) {
        int pre = i - 1;
        int temp = array[i];
        while (pre >= 0 && array[pre] > temp) {
            array[pre + 1] = array[pre];
            pre--;
        }
        array[pre + 1] = temp;
    }
}
```

### 合并排序

```java
private void sort(int[] array) {
    array= mergeSort(array, 0, array.length - 1);
}

private int[] mergeSort(int[] array, int left, int right) {
    if (left == right) {
        return new int[]{array[left]};
    }
    int mid = left + (right - left) / 2;
    int[] leftArray = mergeSort(array, left, mid);
    int[] rightArray = mergeSort(array, mid + 1, right);
    int[] tempArray = new int[leftArray.length + rightArray.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < leftArray.length && j < rightArray.length) {
        if (leftArray[i] < rightArray[j]) {
            tempArray[k++] = leftArray[i++];
        } else {
            tempArray[k++] = leftArray[j++];
        }
    }
    while (i < leftArray.length) {
        tempArray[k++] = leftArray[i++];
    }
    while (j < leftArray.length) {
        tempArray[k++] = leftArray[j++];
    }
    return tempArray;
}
```

## 数组

长度最小的子数组 209

### 二分查找 704

https://leetcode.cn/problems/binary-search/description/

（版本一）左闭右闭区间

```java
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

（版本二）左闭右开区间

这里使用 < ,因为left == right在区间[left, right)是没有意义的

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid;
        }
        return -1;
    }
}
```

另外的左闭右开写法
```java
class Solution {
    public int search(int[] nums, int target) {
        int i = lowerBound2(nums, target);
        return nums[i] == target ? i : -1;
    }
    
    // 闭区间写法
    private int lowerBound(int[] nums, int target) {
        int left = 0, right = nums.length - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // 范围缩小到 [mid+1, right]
            else
                right = mid - 1; // 范围缩小到 [left, mid-1]
        }
        return left; // 或者 right+1
    }

    
   // 左闭右开区间写法
    private int lowerBound2(int[] nums, int target) {
        int left = 0, right = nums.length; // 左闭右开区间 [left, right)
        while (left < right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] < target)
                left = mid + 1; // 范围缩小到 [mid+1, right)
            else
                right = mid; // 范围缩小到 [left, mid)
        }
        return left; // 或者 right
    }
}
```

![二分法2](../../../.vuepress/public/img\二分法1.png)![二分法3](../../../.vuepress/public/img\二分法2.png)![二分法1](../../../.vuepress/public/img\二分法3.png)

### 移除元素  27

https://leetcode.cn/problems/remove-element/

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        int fast = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[slow++] = nums[fast++];
            } else {
                fast++;
            }
        }
        return slow;
    }
}
```

### 有序数组的平方 977

https://leetcode.cn/problems/squares-of-a-sorted-array/

```java
class Solution {
 public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        int[] res = new int[nums.length];
        int index = right;
        while (left <= right) {
            if (nums[left] * nums[left] < nums[right] * nums[right]) {
                res[index] = nums[right] * nums[right];
                right--;
            } else {
                res[index] = nums[left] * nums[left];
                left++;
            }
            index--;
        }
        return res;
    }
}
```

### 长度最小的子数组 209

https://leetcode.cn/problems/minimum-size-subarray-sum/

```java
// 滑动窗口
public int minSubArrayLen(int s, int[] nums) {
    int left = 0;
    int sum = 0;
    int result = Integer.MAX_VALUE;
    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];
        while (sum >= s) {
            result = Math.min(result, right - left + 1);
            sum -= nums[left++];
        }
    }
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

### 螺旋矩阵II 59

https://leetcode.cn/problems/spiral-matrix-ii/

```java
class Solution {
public int[][] generateMatrix(int n) {
        int left = 0, top = 0;
        int right = n - 1, down = n - 1;
        int[][] res = new int[n][n];
        int k = 1;
        while (n / 2 > 0) {
            for (int i = left; i < right; i++, k++) {
                res[top][i] = k;
            }
            for (int i = top; i < down; i++, k++) {
                res[i][right] = k;
            }
            for (int i = right; i > left; i--, k++) {
                res[down][i] = k;
            }
            for (int i = down; i > top; i--, k++) {
                res[i][left] = k;
            }
            left++;
            right--;
            top++;
            down--;
            n -= 2;
        }
        if (n != 0) {
            res[res.length/ 2][res.length / 2] = k;
        }
        return res;
    }
}
```

## 链表

链表相交  面试题 02.07

环形链表II 142

### 移除链表元素 203

https://leetcode.cn/problems/remove-linked-list-elements/

```java
public ListNode removeElements(ListNode head, int val) {
    ListNode dummy = new ListNode();
    dummy.next = head;
    ListNode pre = dummy;
    ListNode cur = head;
    while (cur != null) {
        if (cur.val == val) {
            cur = cur.next;
            pre.next = cur;
        } else {
            pre = cur;
            cur = cur.next;
        }
    }
    return dummy.next;
}
```

### 设计链表 707

https://leetcode.cn/problems/design-linked-list/

```java
//单链表
class ListNode {
    int val;
    ListNode next;
    ListNode(){}
    ListNode(int val) {
        this.val=val;
    }
}
public class MyLinkedList {
    ListNode dummy;
    int length;

    public MyLinkedList() {
        dummy = new ListNode();
        length = 0;
    }

    public int get(int index) {
        if (index < 0 || index >= length) {
            return -1;
        }
        ListNode cur = dummy.next;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        ListNode listNode = new ListNode(val);
        listNode.next = dummy.next;
        dummy.next = listNode;
        length++;
    }

    public void addAtTail(int val) {
        ListNode cur = dummy;
        while (cur.next != null) {
            cur = cur.next;
        }
        ListNode listNode = new ListNode(val);
        listNode.next = cur.next;
        cur.next =listNode;
        length++;
    }

    public void addAtIndex(int index, int val) {
        if (index < 0 || index > length) {
            return;
        }
        ListNode cur = dummy;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        ListNode listNode = new ListNode(val);
        listNode.next = cur.next;
        cur.next = listNode;
        length++;
    }

    public void deleteAtIndex(int index) {
        if (index >= length) {
            return;
        }
        ListNode cur = dummy;
        for (int i = 0; i < index; i++) {
            cur = cur.next;
        }
        if (cur.next != null) {
            cur.next = cur.next.next;
        }
        length--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 反转链表 206

https://leetcode.cn/problems/reverse-linked-list/description/

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode pre = head;
        ListNode cur = head.next;
        pre.next = null;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

### 两两交换链表中的节点 24

https://leetcode.cn/problems/swap-nodes-in-pairs/

```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode pre = head;
    ListNode cur = head.next;
    ListNode next = cur.next;
    cur.next = pre;
    pre.next = swapPairs(next);
    return cur;
}
```

### 删除链表的倒数第N个节点 19

https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode slow = dummy;
        ListNode fast = dummy;
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        //slow 是删除结点的前一个结点
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

### 链表相交  面试题 02.07

https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/

设交集链表长c,链表1除交集的长度为a，链表2除交集的长度为b，有

- a + c + b = b + c + a
- 若无交集，则a + b = b + a

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    ListNode pA = headA, pB = headB;
    while (pA != pB) {
        pA = pA == null ? headB : pA.next;
        pB = pB == null ? headA : pB.next;
    }
    return pA;
}
```

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode curA = headA;
    ListNode curB = headB;
    int lenA = 0, lenB = 0;
    while (curA != null) { // 求链表A的长度
        lenA++;
        curA = curA.next;
    }
    while (curB != null) { // 求链表B的长度
        lenB++;
        curB = curB.next;
    }
    curA = headA;
    curB = headB;
    // 让curA为最长链表的头，lenA为其长度
    if (lenB > lenA) {
        //1. swap (lenA, lenB);
        int tmpLen = lenA;
        lenA = lenB;
        lenB = tmpLen;
        //2. swap (curA, curB);
        ListNode tmpNode = curA;
        curA = curB;
        curB = tmpNode;
    }
    // 求长度差
    int gap = lenA - lenB;
    // 让curA和curB在同一起点上（末尾位置对齐）
    while (gap-- > 0) {
        curA = curA.next;
    }
    // 遍历curA 和 curB，遇到相同则直接返回
    while (curA != null) {
        if (curA == curB) {
            return curA;
        }
        curA = curA.next;
        curB = curB.next;
    }
    return null;
}

```



### 环形链表II 142

https://leetcode.cn/problems/linked-list-cycle-ii/description/

https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF

![环形链表](../../../.vuepress/public/img\环形链表.jpg)

![环形链表1](../../../.vuepress/public/img\环形链表1.jpg)

![环形链表2](../../../.vuepress/public/img\环形链表2.jpg)

```java
//https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

## 哈希表

三数之和



### 有效的字母异位词 242

https://leetcode.cn/problems/valid-anagram/description/

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        int[] num = new int[26];
        for (int i = 0; i < s.length(); i++) {
            num[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            num[t.charAt(i) - 'a']--;
            if (num[t.charAt(i) - 'a'] < 0) {
                return false;
            }
        }
        return true;
    }
}
```

###  两个数组的交集 349

https://leetcode.cn/problems/intersection-of-two-arrays/description/

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Map<Integer, Boolean> map = new HashMap<>();
        for (int i = 0; i < nums1.length; i++) {
            map.put(nums1[i], Boolean.TRUE);
        }
        for (int i = 0; i < nums2.length; i++) {
            if (map.get(nums2[i]) == Boolean.TRUE) {
                set.add(nums2[i]);
            }
        }
        int[] res = new int[set.size()];
        int index = 0;
        Iterator<Integer> iterator = set.iterator();
        while (iterator.hasNext()) {
            res[index++] = iterator.next();
        }
        return res;
    }
}
```

### 快乐数 202

https://leetcode.cn/problems/happy-number/description/

```java
class Solution {
public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while (set.add(n)) {
            int temp = 0;
            while (n != 0) {
                temp += (int) Math.pow(n % 10, 2);
                n /= 10;
            }
            if (temp == 1) {
                return true;
            }
            n = temp;
        }
        return false;
    }
}
```

### 两数之和 1

https://leetcode.cn/problems/two-sum/description/

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.get(target - nums[i]) != null) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

### 四数相加II 454

https://leetcode.cn/problems/4sum-ii/description/

```java
public class fourSumCount {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int res = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        //统计两个数组中的元素之和，同时统计出现的次数，放入map
        for (int i : nums1) {
            for (int j : nums2) {
                int sum = i + j;
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数
        for (int i : nums3) {
            for (int j : nums4) {
                res += map.getOrDefault(0 - i - j, 0);
            }
        }
        return res;
    }
}
```

### 赎金信 383

https://leetcode.cn/problems/ransom-note/description/

```java
public class canConstruct {
    public boolean canConstruct(String ransomNote, String magazine) {
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < magazine.length(); i++) {
            map.put(magazine.charAt(i), map.getOrDefault(magazine.charAt(i), 0) + 1);
        }
        for (int i = 0; i < ransomNote.length(); i++) {
            if (map.get(ransomNote.charAt(i)) == null || map.get(ransomNote.charAt(i)) < 1) {
                return false;
            }
            map.put(ransomNote.charAt(i), map.get(ransomNote.charAt(i)) - 1);
        }
        return true;
    }
}
```

### 三数之和 15

https://leetcode.cn/problems/3sum/description/

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    Arrays.sort(nums);
    // 找出a + b + c = 0
    // a = nums[i], b = nums[left], c = nums[right]
    for (int i = 0; i < nums.length; i++) {
        // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
        if (nums[i] > 0) { 
            return result;
        }

        if (i > 0 && nums[i] == nums[i - 1]) {  // 去重a
            continue;
        }

        int left = i + 1;
        int right = nums.length - 1;
        while (right > left) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum > 0) {
                right--;
            } else if (sum < 0) {
                left++;
            } else {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;

                right--; 
                left++;
            }
        }
    }
    return result;
}
```



### 四数之和 18

https://leetcode.cn/problems/4sum/

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
       
        for (int i = 0; i < nums.length; i++) {
		
            // nums[i] > target 直接返回, 剪枝操作
            if (nums[i] > 0 && nums[i] > target) {
                return result;
            }
		
            if (i > 0 && nums[i - 1] == nums[i]) {    // 对nums[i]去重
                continue;
            }
            
            for (int j = i + 1; j < nums.length; j++) {

                if (j > i + 1 && nums[j - 1] == nums[j]) {  // 对nums[j]去重
                    continue;
                }

                int left = j + 1;
                int right = nums.length - 1;
                while (right > left) {
		    // nums[k] + nums[i] + nums[left] + nums[right] > target int会溢出
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum > target) {
                        right--;
                    } else if (sum < target) {
                        left++;
                    } else {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        left++;
                        right--;
                    }
                }
            }
        }
        return result;
    }
}
```

## 字符串

反转字符串II 替换数字 实现 strStr() 重复的子字符串

### 反转字符串 344

https://leetcode.cn/problems/reverse-string/

```java
public void reverseString(char[] s) {
    int l = 0;
    int r = s.length - 1;
    while(l < r){
        char temp = s[l];
        s[l] = s[r];
        s[r] = temp;
        l++;
        r--;
    }
}
```

### 反转字符串II 541

https://leetcode.cn/problems/reverse-string-ii/description/

```java
public String reverseStr(String s, int k) {
    char[] ch = s.toCharArray();
    for(int i = 0;i < ch.length;i += 2 * k){
        int start = i;
        // 判断尾数够不够k个来取决end指针的位置
        int end = Math.min(ch.length - 1,start + k - 1);
        while(start < end){
            char temp = ch[start];
            ch[start] = ch[end];
            ch[end] = temp;

            start++;
            end--;
        }
    }
    return new String(ch);
}
```

### 替换数字

https://kamacoder.com/problempage.php?pid=1064

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。

```java
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        int len = s.length();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) >= 0 && s.charAt(i) <= '9') {
                len += 5;
            }
        }

        char[] ret = new char[len];
        for (int i = 0; i < s.length(); i++) {
            ret[i] = s.charAt(i);
        }
        for (int i = s.length() - 1, j = len - 1; i >= 0; i--) {
            if ('0' <= ret[i] && ret[i] <= '9') {
                ret[j--] = 'r';
                ret[j--] = 'e';
                ret[j--] = 'b';
                ret[j--] = 'm';
                ret[j--] = 'u';
                ret[j--] = 'n';
            } else {
                ret[j--] = ret[i];
            }
        }
        System.out.println(ret);
    }
}
```

### 翻转字符串里的单词 151

https://leetcode.cn/problems/reverse-words-in-a-string/

```java
/**
     * 不使用Java内置方法实现
     * <p>
     * 1.去除首尾以及中间多余空格
     * 2.反转整个字符串
     * 3.反转各个单词
     */
public String reverseWords(String s) {
    // System.out.println("ReverseWords.reverseWords2() called with: s = [" + s + "]");
    // 1.去除首尾以及中间多余空格
    StringBuilder sb = removeSpace(s);
    // 2.反转整个字符串
    reverseString(sb, 0, sb.length() - 1);
    // 3.反转各个单词
    reverseEachWord(sb);
    return sb.toString();
}

private StringBuilder removeSpace(String s) {
    // System.out.println("ReverseWords.removeSpace() called with: s = [" + s + "]");
    int start = 0;
    int end = s.length() - 1;
    while (s.charAt(start) == ' ') start++;
    while (s.charAt(end) == ' ') end--;
    StringBuilder sb = new StringBuilder();
    while (start <= end) {
        char c = s.charAt(start);
        if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') {
            sb.append(c);
        }
        start++;
    }
    // System.out.println("ReverseWords.removeSpace returned: sb = [" + sb + "]");
    return sb;
}

/**
     * 反转字符串指定区间[start, end]的字符
     */
public void reverseString(StringBuilder sb, int start, int end) {
    // System.out.println("ReverseWords.reverseString() called with: sb = [" + sb + "], start = [" + start + "], end = [" + end + "]");
    while (start < end) {
        char temp = sb.charAt(start);
        sb.setCharAt(start, sb.charAt(end));
        sb.setCharAt(end, temp);
        start++;
        end--;
    }
    // System.out.println("ReverseWords.reverseString returned: sb = [" + sb + "]");
}

private void reverseEachWord(StringBuilder sb) {
    int start = 0;
    int end = 1;
    int n = sb.length();
    while (start < n) {
        while (end < n && sb.charAt(end) != ' ') {
            end++;
        }
        reverseString(sb, start, end - 1);
        start = end + 1;
        end = start + 1;
    }
}
```

### 右旋字符串

https://kamacoder.com/problempage.php?pid=1065

```java
public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    int n = Integer.parseInt(in.nextLine());
    String s = in.nextLine();

    int len = s.length();  //获取字符串长度
    char[] chars = s.toCharArray();
    reverseString(chars, 0, len - 1);  //反转整个字符串
    reverseString(chars, 0, n - 1);  //反转前一段字符串，此时的字符串首尾尾是0,n - 1
    reverseString(chars, n, len - 1);  //反转后一段字符串，此时的字符串首尾尾是n,len - 1

    System.out.println(chars);

}

public static void reverseString(char[] ch, int start, int end) {
    //异或法反转字符串，参照题目 344.反转字符串的解释
    while (start < end) {
        ch[start] ^= ch[end];
        ch[end] ^= ch[start];
        ch[start] ^= ch[end];
        start++;
        end--;
    }
}
```

### 实现 strStr() 28

https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string

https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF

![kmp](../../../.vuepress/public/img\kmp.jpg)

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;
    int[] next = new int[needle.length()];
    getNext(next, needle);

    int j = 0;
    for (int i = 0; i < haystack.length(); i++) {
        while (j > 0 && needle.charAt(j) != haystack.charAt(i)) 
            j = next[j - 1];
        if (needle.charAt(j) == haystack.charAt(i)) 
            j++;
        if (j == needle.length()) 
            return i - needle.length() + 1;
    }
    return -1;

}
    
private void getNext(int[] next, String s) {
    int j = 0;
    next[0] = 0;
    for (int i = 1; i < s.length(); i++) {
        while (j > 0 && s.charAt(j) != s.charAt(i)) 
            j = next[j - 1];
        if (s.charAt(j) == s.charAt(i)) 
            j++;
        next[i] = j; 
    }
}
```

### 重复的子字符串 459

https://leetcode.cn/problems/repeated-substring-pattern/description/

![重复字符串](../../../.vuepress/public/img\重复字符串.jpg)

![重复的子字符串](../../../.vuepress/public/img\重复的子字符串.jpg)

![重复的子字符串1](../../../.vuepress/public/img\重复的子字符串1.jpg)

数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。

```c++
//https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF
public:
void getNext (int* next, const string& s){
    next[0] = 0;
    int j = 0;
    for(int i = 1;i < s.size(); i++){
        while(j > 0 && s[i] != s[j]) {
            j = next[j - 1];
        }
        if(s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
bool repeatedSubstringPattern (string s) {
    if (s.size() == 0) {
        return false;
    }
    int next[s.size()];
    getNext(next, s);
    int len = s.size();
    if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {
        return true;
    }
    return false;
}
```

## 栈与队列

### 用栈实现队列 232

滑动窗口最大值 239

```java
class MyQueue {

    Stack<Integer> pushStack;
    Stack<Integer> popStack;
    
    public MyQueue() {
        pushStack = new Stack<>();
        popStack = new Stack<>();
    }

    public void push(int x) {
        pushStack.push(x);
    }

    public int pop() {
        if (!popStack.isEmpty()) {
            return popStack.pop();
        }
        while (!pushStack.isEmpty()) {
            popStack.push(pushStack.pop());
        }
        return popStack.pop();
    }

    public int peek() {
        if (!popStack.isEmpty()) {
            return popStack.peek();
        }
        while (!pushStack.isEmpty()) {
            popStack.push(pushStack.pop());
        }
        return popStack.peek();
    }

    public boolean empty() {
        return pushStack.empty() && popStack.empty();
    }
}
```

### 用队列实现栈 225

滑动窗口最大值

https://leetcode.cn/problems/implement-stack-using-queues

```
public class MyStack {
    Queue<Integer> pushQueue;
    Queue<Integer> popQueue;

    public MyStack() {
        pushQueue = new ArrayDeque<>();
        popQueue = new ArrayDeque<>();
    }

    public void push(int x) {
        if (pushQueue.isEmpty()) {
            popQueue.add(x);
        } else {
            pushQueue.add(x);
        }
    }

    public int pop() {
        if (pushQueue.isEmpty()) {
            while (popQueue.size() > 1) {
                pushQueue.add(popQueue.poll());
            }
            return !popQueue.isEmpty() ? popQueue.poll() : -1;
        }
        if (popQueue.isEmpty()) {
            while (pushQueue.size() > 1) {
                popQueue.add(pushQueue.poll());
            }
            return !pushQueue.isEmpty() ? pushQueue.poll() : -1;
        }
        return -1;
    }

    public int top() {
        if (pushQueue.isEmpty()) {
            while (popQueue.size() > 1) {
                pushQueue.add(popQueue.poll());
            }
            int poll = popQueue.isEmpty() ? -1 : popQueue.poll();
            pushQueue.add(poll);
            return poll;
        }
        if (popQueue.isEmpty()) {
            while (pushQueue.size() > 1) {
                popQueue.add(pushQueue.poll());
            }
            int poll = pushQueue.isEmpty() ? -1 : pushQueue.poll();
            popQueue.add(poll);
            return poll;
        }
        return -1;
    }

    public boolean empty() {
        return popQueue.isEmpty() && pushQueue.isEmpty();
    }
}
```

### 有效的括号 20

https://leetcode.cn/problems/valid-parentheses/

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    int length = s.length();
    int left = 0;
    while (left < length) {
        char c = s.charAt(left);
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }
            Character pop = stack.pop();
            if ((pop == '(' && c != ')') || (pop == '{' && c != '}')
                || (pop == '[' && c != ']')) {
                return false;
            }
        }
        left++;
    }
    return stack.isEmpty();
}
```

### 删除字符串中的所有相邻重复项

https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/

```java
class Solution {
    public String removeDuplicates(String s) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (stack.isEmpty()) {
                stack.push(s.charAt(i));
                continue;
            }
            if (s.charAt(i) == stack.peek()) {
                stack.pop();
                continue;
            }
            stack.push(s.charAt(i));
        }
        StringBuilder stringBuilder = new StringBuilder();
        while (!stack.isEmpty()) {
            stringBuilder.append(stack.pop());
        }
        return stringBuilder.reverse().toString();
    }
}
```

### 逆波兰表达式求值 150

https://leetcode.cn/problems/evaluate-reverse-polish-notation

```java
public int evalRPN(String[] tokens) {
    int sum = 0;
    Stack<String> stack = new Stack<>();
    for (String token : tokens) {
        if (token.equals("+") || token.equals("-")
            || token.equals("*") || token.equals("/")) {
            int pop = Integer.parseInt(stack.pop());
            int pop1 = Integer.parseInt(stack.pop());
            if (token.equals("+")) {
                sum = pop + pop1;
                stack.push(String.valueOf(sum));
                continue;
            }
            if (token.equals("-")) {
                sum = pop1 - pop;
                stack.push(String.valueOf(sum));
                continue;
            }
            if (token.equals("/")) {
                sum = pop1 / pop;
                stack.push(String.valueOf(sum));
                continue;
            }
            sum = pop * pop1;
            stack.push(String.valueOf(sum));
        } else {
            stack.push(token);
        }
    }
    return Integer.parseInt(stack.pop());
}
```

### 滑动窗口最大值 239

https://leetcode.cn/problems/sliding-window-maximum/description/

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair1[1] - pair2[1];
            }
        });
        for (int i = 0; i < k; ++i) {
            pq.offer(new int[]{nums[i], i});
        }
        int[] ans = new int[n - k + 1];
        ans[0] = pq.peek()[0];
        for (int i = k; i < n; ++i) {
            pq.offer(new int[]{nums[i], i});
            while (pq.peek()[1] <= i - k) {
                pq.poll();
            }
            ans[i - k + 1] = pq.peek()[0];
        }
        return ans;
    }
}
```

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n - k + 1];
        int idx = 0;
        for(int i = 0; i < n; i++) {
            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出
            while(!deque.isEmpty() && deque.peek() < i - k + 1){
                deque.poll();
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出
            while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if(i >= k - 1){
                res[idx++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```



### 前 K 个高频元素

https://leetcode.cn/problems/top-k-frequent-elements/

```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
    }
    PriorityQueue<int[]> priorityQueue = new PriorityQueue<>(new Comparator<int[]>() {
        @Override
        public int compare(int[] o1, int[] o2) {
            return o2[1] - o1[1];
        }
    });
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        priorityQueue.add(new int[]{entry.getKey(), entry.getValue()});
    }
    for (int i = 0; i < k; i++) {
        res[i] = priorityQueue.poll()[0];
    }
    return res;
}
```

## 二叉树

### 二叉树递归遍历

二叉树迭代遍历

二叉树的统一迭代遍历

验证二叉搜索树

二叉搜索树中的众数

二叉树的最近公共祖先

二叉搜索树的最近公共祖先

删除二叉搜索树中的节点

#### 前序遍历 144

https://leetcode.cn/problems/binary-tree-preorder-traversal

```java
List<Integer> res;

public List<Integer> preorderTraversal(TreeNode root) {
    res = new ArrayList<>();
    preorder(root);
    return res;
}

private void preorder(TreeNode root) {
    if (root == null) {
        return;
    }
    res.add(root.val);
    preorder(root.left);
    preorder(root.right);
}
```

#### 中序遍历 94

https://leetcode.cn/problems/binary-tree-inorder-traversal/

```java
List<Integer> res;
public List<Integer> inorderTraversal(TreeNode root) {
    res = new ArrayList<>();
    inorder(root);
    return res;
}

private void inorder(TreeNode root) {
    if (root == null) {
        return;
    }
    inorder(root.left);
    res.add(root.val);
    inorder(root.right);
}
```

#### 后续遍历 145

https://leetcode.cn/problems/binary-tree-postorder-traversal/

```java
List<Integer> res;
public List<Integer> postorderTraversal(TreeNode root) {
    res = new ArrayList<>();
    postorder(root);
    return res;
}

private void postorder(TreeNode root) {
    if (root == null) {
        return;
    }
    postorder(root.left);
    postorder(root.right);
    res.add(root.val);
}
```



### 二叉树迭代遍历

#### 前序遍历 144

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null){
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.right != null){
            stack.push(node.right);
        }
        if (node.left != null){
            stack.push(node.left);
        }
    }
    return result;
}
```

#### 中序遍历 94

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null){
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    //遍历指针为空并且栈为空 循环终止
    while (cur != null || !stack.isEmpty()){
        if (cur != null){
            stack.push(cur);
            cur = cur.left;
        }else{
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;
        }
    }
    return result;
}
```

#### 后续遍历 145

![后序迭代遍历](../../../.vuepress/public/img\后序迭代遍历.jpg)

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null){
        return result;
    }
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()){
        TreeNode node = stack.pop();
        result.add(node.val);
        if (node.left != null){
            stack.push(node.left);
        }
        if (node.right != null){
            stack.push(node.right);
        }
    }
    Collections.reverse(result);
    return result;
}
```



### 二叉树的统一迭代遍历

处理的节点放入栈之后，紧接着放入一个空指针作为标记

#### 前序遍历 144

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> st = new Stack<>();
    if (root != null) st.push(root);
    while (!st.empty()) {
        TreeNode node = st.peek();
        if (node != null) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
            st.push(node);                          // 添加中节点
            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.peek();    // 重新取出栈中元素
            st.pop();
            result.add(node.val); // 加入到结果集
        }
    }
    return result;
}
```

#### 中序遍历 94

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> st = new Stack<>();
    if (root != null) st.push(root);
    while (!st.empty()) {
        TreeNode node = st.peek();
        if (node != null) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
            st.push(node);                          // 添加中节点
            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.peek();    // 重新取出栈中元素
            st.pop();
            result.add(node.val); // 加入到结果集
        }
    }
    return result;
}
```

#### 后续遍历 145

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    Stack<TreeNode> st = new Stack<>();
    if (root != null) st.push(root);
    while (!st.empty()) {
        TreeNode node = st.peek();
        if (node != null) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            st.push(node);                          // 添加中节点
            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         

        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.peek();    // 重新取出栈中元素
            st.pop();
            result.add(node.val); // 加入到结果集
        }
    }
    return result;
}
```



### 二叉树层次遍历

#### 二叉树的层序遍历 102

https://leetcode.cn/problems/binary-tree-level-order-traversal/

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new ArrayDeque<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        List<Integer> temp = new ArrayList<>();
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode poll = queue.poll();
            temp.add(poll.val);
            if (poll.left != null) {
                queue.add(poll.left);
            }
            if (poll.right != null) {
                queue.add(poll.right);
            }
        }
        res.add(temp);
    }
    return res;
}
```

#### 填充每个节点的下一个右侧节点指针 116

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/

```java
public Node connect(Node root) {
    Queue<Node> queue = new ArrayDeque<>();
    if (root == null) {
        return root;
    }
    queue.add(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = queue.poll();
        if (pre.left != null) {
            queue.add(pre.left);
        }
        if (pre.right != null) {
            queue.add(pre.right);
        }
        Node cur;
        for (int i = 1; i < size; i++) {
            cur = queue.poll();
            if (cur.left != null) {
                queue.add(cur.left);
            }
            if (cur.right != null) {
                queue.add(cur.right);
            }
            pre.next = cur;
            pre = cur;
        }
    }
    return root;
}
```
#### 二叉树的最大深度 104

**层次遍历**

https://leetcode.cn/problems/maximum-depth-of-binary-tree

```java
public int maxDepth(TreeNode root) {
        int maxDepth = 0;
        Queue<TreeNode> queue = new ArrayDeque<>();
        if (root == null) {
            return 0;
        }
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            maxDepth++;
            for (int i = 0; i < size; i++) {
                TreeNode poll = queue.poll();
                if (poll.left != null) {
                    queue.add(poll.left);
                }
                if (poll.right != null) {
                    queue.add(poll.right);
                }
            }
        }
        return maxDepth;
    }
```

**递归遍历**

```java
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```



#### 二叉树的最小深度 111

https://leetcode.cn/problems/minimum-depth-of-binary-tree

**层次遍历**

```java
public int minDepth(TreeNode root) {
    int minDepth = 0;
    Queue<TreeNode> queue = new ArrayDeque<>();
    if (root == null) {
        return 0;
    }
    queue.add(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        minDepth++;
        for (int i = 0; i < size; i++) {
            TreeNode poll = queue.poll();
            if (poll.left == null && poll.right == null) {
                return minDepth;
            }
            if (poll.left != null) {
                queue.add(poll.left);
            }
            if (poll.right != null) {
                queue.add(poll.right);
            }
        }
    }
    return minDepth;
}
```

**递归遍历**

```java
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null && root.right == null) {
        return 1;
    }
    if (root.left == null && root.right != null) {
        return minDepth(root.right) + 1;
    }
    if (root.left != null && root.right == null) {
        return minDepth(root.left) + 1;
    }
    return Math.min(minDepth(root.right), minDepth(root.left)) + 1;
}
```

### 翻转二叉树 226

https://leetcode.cn/problems/invert-binary-tree/

```java
public TreeNode invertTree(TreeNode root) {
    invertTreeDfs(root);
    return root;
}

private void invertTreeDfs(TreeNode root) {
    if (root == null) {
        return;
    }
    if (root.left != null) {
        invertTree(root.left);
    }
    if (root.right != null) {
        invertTree(root.right);
    }
    TreeNode left = root.left;
    TreeNode right = root.right;
    root.right = left;
    root.left = right;
}
```

### 对称二叉树 101

https://leetcode.cn/problems/symmetric-tree/

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return checkSymmetric(root.left, root.right);
}

private boolean checkSymmetric(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left == null && right != null) {
        return false;
    }
    if (left != null && right == null) {
        return false;
    }
    if (left != null && right != null && left.val != right.val) {
        return false;
    }
    return checkSymmetric(left.left, right.right) && checkSymmetric(left.right, right.left);
}
```



### 完全二叉树的节点个数

https://leetcode.cn/problems/count-complete-tree-nodes/

```java
public int countNodes(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}
```

```java
/**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    TreeNode left = root.left;
    TreeNode right = root.right;
    int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
    while (left != null) {  // 求左子树深度
        left = left.left;
        leftDepth++;
    }
    while (right != null) { // 求右子树深度
        right = right.right;
        rightDepth++;
    }
    if (leftDepth == rightDepth) {
        return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
    }
    return countNodes(root.left) + countNodes(root.right) + 1;
}
```

### 平衡二叉树 110

```java
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }
    int leftDepth = getMaxDepth(root.left);
    int rightDepth = getMaxDepth(root.right);
    if (Math.abs(leftDepth - rightDepth) > 1) {
        return false;
    }
    return isBalanced(root.left) && isBalanced(root.right);
}

private int getMaxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(getMaxDepth(root.right), getMaxDepth(root.left)) + 1;
}
```

### 二叉树的所有路径 257

https://leetcode.cn/problems/binary-tree-paths/description/

```java
List<String> list;

public List<String> binaryTreePaths(TreeNode root) {
    list = new ArrayList<>();
    if (root == null) {
        return list;
    }
    binaryTreePath(root, "");
    return list;
}

private void binaryTreePath(TreeNode root, String s) {
    if (root.left == null && root.right == null) {
        s = s + root.val;
        list.add(s);
        return;
    }
    String t = s + root.val + "->";
    if (root.left != null) {
        binaryTreePath(root.left, t);
    }
    if (root.right != null) {
        binaryTreePath(root.right, t);
    }
}
```

```java
//方式一
class Solution {
    /**
     * 递归法
     */
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();// 存最终的结果
        if (root == null) {
            return res;
        }
        List<Integer> paths = new ArrayList<>();// 作为结果中的路径
        traversal(root, paths, res);
        return res;
    }

    private void traversal(TreeNode root, List<Integer> paths, List<String> res) {
        paths.add(root.val);// 前序遍历，中
        // 遇到叶子结点
        if (root.left == null && root.right == null) {
            // 输出
            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快
            for (int i = 0; i < paths.size() - 1; i++) {
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点
            res.add(sb.toString());// 收集一个路径
            return;
        }
        // 递归和回溯是同时进行，所以要放在同一个花括号里
        if (root.left != null) { // 左
            traversal(root.left, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
        if (root.right != null) { // 右
            traversal(root.right, paths, res);
            paths.remove(paths.size() - 1);// 回溯
        }
    }
}

//方式二
class Solution {

    List<String> result = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        deal(root, "");
        return result;
    }

    public void deal(TreeNode node, String s) {
        if (node == null)
            return;
        if (node.left == null && node.right == null) {
            result.add(new StringBuilder(s).append(node.val).toString());
            return;
        }
        String tmp = new StringBuilder(s).append(node.val).append("->").toString();
        deal(node.left, tmp);
        deal(node.right, tmp);
    }
}
```

### 左叶子之和 404

https://leetcode.cn/problems/sum-of-left-leaves/

```java
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int sum = 0;
    if (root.left != null && root.left.right == null
        && root.left.left == null) {
        sum += root.left.val;
    }
    return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}
```

### 找树左下角的值 513

https://leetcode.cn/problems/find-bottom-left-tree-value/description/

```java
int bottomLeftVal = 0;
int maxHeight = 0;

public int findBottomLeftValue(TreeNode root) {
    bottomLeftVal = root.val;
    dfs(root, 0);
    return bottomLeftVal;
}

private void dfs(TreeNode root, int height) {
    if (root == null) {
        return;
    }
    if (height > maxHeight) {
        maxHeight = height;
        bottomLeftVal = root.val;
    }
    dfs(root.left, height + 1);
    dfs(root.right, height + 1);
}
```

### 路径总和 112

https://leetcode.cn/problems/path-sum/description/

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    if (root == null) {
        return false;
    }
    return dfs(root, targetSum);
}

private boolean dfs(TreeNode root, int leftValue) {
    if (root.left == null && root.right == null && leftValue == root.val) {
        return true;
    }
    if (root.left == null && root.right == null && leftValue != root.val) {
        return false;
    }
    boolean left = false;
    if (root.left != null) {
        left = dfs(root.left, leftValue - root.val);
    }
    boolean right = false;
    if (root.right != null) {
        right = dfs(root.right, leftValue - root.val);
    }
    return left || right;
}
```

### 从中序与后序遍历序列构造二叉树 106

https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

```java
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if (postorder.length == 0) {
        return null;
    }
    int length = inorder.length - 1;
    return buildTreeOrder(inorder, 0, length, postorder, 0, length);
}

private TreeNode buildTreeOrder(int[] inorder, int inLeft, int inRight, int[] postorder, int postLeft,
                                int postRight) {
    if (inLeft > inRight) {
        return null;
    }
    if (inLeft == inRight) {
        return new TreeNode(inorder[inLeft]);
    }
    int headValue = postorder[postRight];
    // 根结点位置
    int index = getIndex(inorder, headValue);
    TreeNode root = new TreeNode(inorder[index]);
    // 左子树的结点数
    // int leftCount = index - inLeft;
    // 右子树的结点数
    // int rightCount = inRight - index;
    root.left = buildTreeOrder(inorder, inLeft, index - 1, postorder, postLeft, postLeft + index - inLeft - 1);
    root.right = buildTreeOrder(inorder, index + 1, inRight, postorder, postRight - inRight + index, postRight - 1);
    return root;
}

private int getIndex(int[] inorder, int headValue) {
    for (int i = 0; i < inorder.length; i++) {
        if (headValue == inorder[i]) {
            return i;
        }
    }
    return -1;
}
```



### 从前序与中序遍历序列构造二叉树 105

https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder.length == 0) {
        return null;
    }
    int length = preorder.length - 1;
    return buildTreeOrder(preorder, 0, length, inorder, 0, length);
}

private TreeNode buildTreeOrder(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) {
    if (preLeft > preRight) {
        return null;
    }
    if (preLeft == preRight) {
        return new TreeNode(preorder[preLeft]);
    }
    int headValue = preorder[preLeft];
    int index = getIndex(inorder, headValue);
    TreeNode root = new TreeNode(inorder[index]);
    // 左子树的个数
    // index-inLeft
    // 右子树的个数
    // inRight - index
    root.left = buildTreeOrder(preorder, preLeft + 1, index - inLeft + preLeft, inorder, inLeft, index - 1);
    root.right = buildTreeOrder(preorder, preRight - inRight + index + 1, preRight, inorder, index + 1, inRight);
    return root;
}

private int getIndex(int[] inorder, int headValue) {
    for (int i = 0; i < inorder.length; i++) {
        if (headValue == inorder[i]) {
            return i;
        }
    }
    return -1;
}

```

### 最大二叉树 654

https://leetcode.cn/problems/maximum-binary-tree/description/

```java
public TreeNode constructMaximumBinaryTree(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    return constructBinaryTree(nums, left, right);
}

private TreeNode constructBinaryTree(int[] nums, int left, int right) {
    if (left > right) {
        return null;
    }
    // 最大值
    int index = left;
    int max = -1;
    for (int i = left; i <= right; i++) {
        if (nums[i] >= max) {
            index = i;
            max = nums[i];
        }
    }
    TreeNode root = new TreeNode(max);
    root.left = constructBinaryTree(nums, left, index - 1);
    root.right = constructBinaryTree(nums, index + 1, right);
    return root;
}
```

### 合并二叉树 617

https://leetcode.cn/problems/merge-two-binary-trees/description/

```java
public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    int val = root1.val + root2.val;
    TreeNode root = new TreeNode(val);
    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);
    return root;
}
```
### 验证二叉搜索树 98

https://leetcode.cn/problems/validate-binary-search-tree/

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return check(root, Integer.MIN_VALUE, Integer.MAX_VALUE);

}

private boolean check(TreeNode root, int min, int max) {
    if (root == null) {
        return true;
    }
    if (root.val >= max || root.val <= min) {
        return false;
    }
    return check(root.left, min, root.val) && check(root.right, root.val, max);
}
```

### 二叉搜索树中的搜索 700

https://leetcode.cn/problems/search-in-a-binary-search-tree/

```java
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    return check(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean check(TreeNode root, long min, long max) {
    if (root == null) {
        return true;
    }
    if (root.val >= max || root.val <= min) {
        return false;
    }
    return check(root.left, min, root.val) && check(root.right, root.val, max);
}

```

### 二叉搜索树的最小绝对差 530

https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/

```java
List<Integer> list = new ArrayList<>();

public int getMinimumDifference(TreeNode root) {
    dfs(root);
    int min = Integer.MAX_VALUE;
    for (int i = 1; i < list.size(); i++) {
        min = Math.min(min, list.get(i) - list.get(i - 1));
    }
    return min;
}

private void dfs(TreeNode root) {
    if (root == null) {
        return;
    }
    dfs(root.left);
    list.add(root.val);
    dfs(root.right);
}
```

```java
TreeNode pre;// 记录上一个遍历的结点
int result = Integer.MAX_VALUE;
public int getMinimumDifference(TreeNode root) {
    if(root==null)return 0;
    traversal(root);
    return result;
}
public void traversal(TreeNode root){
    if(root==null)return;
    //左
    traversal(root.left);
    //中
    if(pre!=null){
        result = Math.min(result,root.val-pre.val);
    }
    pre = root;
    //右
    traversal(root.right);
}
```




### 二叉搜索树中的众数 501

https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/

```java
ArrayList<Integer> resList;
int maxCount;
int count;
TreeNode pre;

public int[] findMode(TreeNode root) {
    resList = new ArrayList<>();
    maxCount = 0;
    count = 0;
    pre = null;
    findMode1(root);
    int[] res = new int[resList.size()];
    for (int i = 0; i < resList.size(); i++) {
        res[i] = resList.get(i);
    }
    return res;
}

public void findMode1(TreeNode root) {
    if (root == null) {
        return;
    }
    findMode1(root.left);

    int rootValue = root.val;
    // 计数
    if (pre == null || rootValue != pre.val) {
        count = 1;
    } else {
        count++;
    }
    // 更新结果以及maxCount
    if (count > maxCount) {
        resList.clear();
        resList.add(rootValue);
        maxCount = count;
    } else if (count == maxCount) {
        resList.add(rootValue);
    }
    pre = root;

    findMode1(root.right);
}
```

### 二叉树的最近公共祖先 236

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == p || root == q) {
        return root;
    }
    boolean pIn = isInTreeNode(root.left, p);
    boolean qIn = isInTreeNode(root.right, q);
    if (pIn && qIn) {
        return root;
    }
    if (pIn && !qIn) {
        return lowestCommonAncestor(root.left, p, q);
    }
    if (!pIn && qIn) {
        return lowestCommonAncestor(root.right, p, q);
    }
    return root;
}

private boolean isInTreeNode(TreeNode root, TreeNode p) {
    if (root == null) {
        return false;
    }
    if (root == p) {
        return true;
    }
    return isInTreeNode(root.left, p) || isInTreeNode(root.right, p);
}
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) { // 递归结束条件
        return root;
    }

    // 后序遍历
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if(left == null && right == null) { // 若未找到节点 p 或 q
        return null;
    }else if(left == null && right != null) { // 若找到一个节点
        return right;
    }else if(left != null && right == null) { // 若找到一个节点
        return left;
    }else { // 若找到两个节点
        return root;
    }
}
```

### 二叉搜索树的最近公共祖先 235

https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

### 二叉搜索树中的插入操作 701

https://leetcode.cn/problems/insert-into-a-binary-search-tree

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    if (root.left == null && val < root.val) {
        root.left = new TreeNode(val);
        return root;
    }
    if (root.right == null && val > root.val) {
        root.right = new TreeNode(val);
        return root;
    }
    if (val < root.val) {
        root.left = insertIntoBST(root.left, val);
    } else {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
```

### 删除二叉搜索树中的节点 450

https://leetcode.cn/problems/delete-node-in-a-bst/

```java
public TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return root;
    if (root.val == key) {
        if (root.left == null) {
            return root.right;
        } else if (root.right == null) {
            return root.left;
        } else {
            //右子树的最小结点 把左子树放到该结点的左子树上
            TreeNode cur = root.right;
            while (cur.left != null) {
                cur = cur.left;
            }
            cur.left = root.left;
            root = root.right;
            return root;
        }
    }
    if (root.val > key) root.left = deleteNode(root.left, key);
    if (root.val < key) root.right = deleteNode(root.right, key);
    return root;
}
```

### 修剪二叉搜索树 669

https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/

```java
public TreeNode trimBST(TreeNode root, int low, int high) {
    if (root == null) {
        return null;
    }
    if (root.val < low) {
        return trimBST(root.right, low, high);
    }
    if (root.val > high) {
        return trimBST(root.left, low, high);
    }
    root.left = trimBST(root.left, low, root.val);
    root.right = trimBST(root.right, root.val, high);
    return root;
}
```

### 将有序数组转换为二叉搜索树 108

https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return buildBSTTree(nums, 0, nums.length - 1);
}

private TreeNode buildBSTTree(int[] nums, int left, int right) {
    if (left > right) {
        return null;
    }
    if (left == right) {
        return new TreeNode(nums[left]);
    }
    int mid = left + (right - left) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = buildBSTTree(nums, left, mid - 1);
    root.right = buildBSTTree(nums, mid + 1, right);
    return root;
}
```



### 把二叉搜索树转换为累加树 538

https://leetcode.cn/problems/convert-bst-to-greater-tree/description/

```java
int sum = 0;

public TreeNode convertBST(TreeNode root) {
    if (root == null) {
        return null;
    }
    convertBST(root.right);
    root.val += sum;
    sum = root.val;
    convertBST(root.left);
    return root;
}
```

## 回溯算法

递增子序列 491

重新安排行程 332

解数独 37

### 组合 77 

https://leetcode.cn/problems/combinations/

```java
List<List<Integer>> res;

public List<List<Integer>> combine(int n, int k) {
    res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    backtrack(1, temp, n, k);
    return res;
}

private void backtrack(int index, List<Integer> temp, int n, int k) {
    if (temp.size() == k) {
        res.add(new ArrayList<>(temp));
        return;
    }
    if (n - index + 1 + temp.size() < k) {
        return;
    }
    for (int i = index; i <= n; i++) {
        temp.add(i);
        backtrack(i + 1, temp, n, k);
        temp.remove(temp.size() - 1);
    }
}

```

### 组合总和III 216

https://leetcode.cn/problems/combination-sum-iii/description/

```java
List<List<Integer>> res;

public List<List<Integer>> combinationSum3(int k, int n) {
    res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    backTrack(1, temp, k, n);
    return res;
}

private void backTrack(int index, List<Integer> temp, int k, int n) {
    Integer reduce = temp.stream().reduce(0, Integer::sum);
    if (reduce > n) {
        return;
    }
    if (temp.size() == k) {
        if (reduce == n) {
            res.add(new ArrayList<>(temp));
        }
        return;
    }
    if (9 - index + 1 + temp.size() < k) {
        return;
    }
    for (int i = index; i <= 9; i++) {
        temp.add(i);
        backTrack(i + 1, temp, k, n);
        temp.remove(temp.size() - 1);
    }
}

```
优化
```java

List<List<Integer>> res;

public List<List<Integer>> combinationSum3(int k, int n) {
    res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    backTrack(1, temp, k, n, 0);
    return res;
}

private void backTrack(int index, List<Integer> temp, int k, int n, int sum) {
    if (sum > n) {
        return;
    }
    if (temp.size() == k) {
        if (sum == n) {
            res.add(new ArrayList<>(temp));
        }
        return;
    }
    if (n - index + 1 + temp.size() < k) {
        return;
    }
    for (int i = index; i <= 9; i++) {
        temp.add(i);
        backTrack(i + 1, temp, k, n, sum + i);
        temp.remove(temp.size() - 1);
    }
}
```

### 电话号码的字母组合 17

https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/

```java
String[] digitString = { "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
List<String> res;

public List<String> letterCombinations(String digits) {
    if (digits.isEmpty()) {
        return new ArrayList<>();
    }
    res = new ArrayList<>();
    int length = digits.length();
    String temp = "";
    backTrack(0, length, digits, temp);
    return res;
}

private void backTrack(int index, int length, String digits, String temp) {
    if (index == length) {
        res.add(new String(temp));
        return;
    }
    int c = digits.charAt(index) - 48;
    String numberDigits = digitString[c - 2];
    for (int i = 0; i < numberDigits.length(); i++) {
        temp = temp + numberDigits.charAt(i);
        backTrack(index + 1, length, digits, temp);
        temp = temp.subSequence(0, temp.length() - 1).toString();
    }
}
```

```java
//设置全局列表存储最后的结果
List<String> list = new ArrayList<>();

public List<String> letterCombinations(String digits) {
    if (digits == null || digits.length() == 0) {
        return list;
    }
    //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
    String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    //迭代处理
    backTracking(digits, numString, 0);
    return list;

}

//每次迭代获取一个字符串，所以会涉及大量的字符串拼接，所以这里选择更为高效的 StringBuilder
StringBuilder temp = new StringBuilder();

//比如digits如果为"23",num 为0，则str表示2对应的 abc
public void backTracking(String digits, String[] numString, int num) {
    //遍历全部一次记录一次得到的字符串
    if (num == digits.length()) {
        list.add(temp.toString());
        return;
    }
    //str 表示当前num对应的字符串
    String str = numString[digits.charAt(num) - '0'];
    for (int i = 0; i < str.length(); i++) {
        temp.append(str.charAt(i));
        //递归，处理下一层
        backTracking(digits, numString, num + 1);
        //剔除末尾的继续尝试
        temp.deleteCharAt(temp.length() - 1);
    }
}
```

### 组合总和 39

https://leetcode.cn/problems/combination-sum/

```java
List<List<Integer>> res;

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    Arrays.sort(candidates);
    backtrack(0, candidates, 0, target, temp);
    return res;
}

private void backtrack(int index, int[] candidates, int curSum, int target, List<Integer> temp) {
    if (curSum > target) {
        return;
    }
    if (curSum == target) {
        res.add(new ArrayList<>(temp));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        if (curSum + candidates[i] > target) break;
        temp.add(candidates[i]);
        backtrack(i, candidates, curSum + candidates[i], target, temp);
        temp.remove(temp.size() - 1);
    }
}
```

### 组合总和II 40

https://leetcode.cn/problems/combination-sum-ii/

```java
class Solution {
    List<List<Integer>> res;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        res = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        Arrays.sort(candidates);
        boolean[] used = new boolean[candidates.length];
        backtrack(0, candidates, 0, target, temp, used);
        return res;
    }

    private void backtrack(int index, int[] candidates, int curSum, int target, List<Integer> temp, boolean[] used) {
        if (curSum > target) {
            return;
        }
        if (curSum == target) {
            res.add(new ArrayList<>(temp));
            return;
        }
        for (int i = index; i < candidates.length; i++) {
            if (curSum + candidates[i] > target) break;
            if (i > 0 && !used[i - 1] && candidates[i] == candidates[i - 1]) {
                continue;
            }
            temp.add(candidates[i]);
            used[i] = true;
            backtrack(i + 1, candidates, curSum + candidates[i], target, temp, used);
            temp.remove(temp.size() - 1);
            used[i] = false;
        }
    }
}
```

### 分割回文串 131

```java
List<List<String>> res;

public List<List<String>> partition(String s) {
    res = new ArrayList<>();
    List<String> temp = new ArrayList<>();
    backtrack(0, s, temp);
    return res;
}

private void backtrack(int index, String s, List<String> temp) {
    if (index > s.length()) {
        return;
    }
    if (index == s.length()) {
        res.add(new ArrayList<>(temp));
        return;
    }
    for (int i = index; i < s.length(); i++) {
        if (!isSymmer(s, index, i)) {
            continue;
        }
        temp.add(s.substring(index, i + 1));
        backtrack(i + 1, s, temp);
        temp.remove(temp.size() - 1);
    }
}

private boolean isSymmer(String s, int index, int i) {
    while (index < i) {
        if (s.charAt(index++) != s.charAt(i--)) {
            return false;
        }
    }
    return true;
}
```

### 复原IP地址

https://leetcode.cn/problems/restore-ip-addresses/description/

```java
List<List<Integer>> res;

public List<String> restoreIpAddresses(String s) {
    res = new ArrayList<>();
    List<Integer> temp = new ArrayList<>();
    backTrack(0, s, temp);
    List<String> addresses = new ArrayList<>();
    for (int i = 0; i < res.size(); i++) {
        List<Integer> list = res.get(i);
        StringBuilder addressBuilder = new StringBuilder();
        for (int j = 0; j < list.size() - 1; j++) {
            addressBuilder.append(list.get(j));
            addressBuilder.append(".");
        }
        addressBuilder.append(list.get(list.size() - 1));
        addresses.add(new String(addressBuilder));
    }
    return addresses;
}

private void backTrack(int index, String s, List<Integer> temp) {
    if (temp.size() == 4 && index != s.length()) {
        return;
    }
    if (index == s.length() && temp.size() == 4) {
        res.add(new ArrayList<>(temp));
        return;
    }
    for (int i = index; i < s.length(); i++) {
        // 前导0
        if (s.charAt(index) == '0' && i > index) {
            continue;
        }
        String substring = s.substring(index, i + 1);
        int ip = Integer.parseInt(substring);
        if (ip > 255) {
            break;
        }
        temp.add(ip);
        backTrack(i + 1, s, temp);
        temp.remove(temp.size() - 1);
    }
}
```

### 子集 78

https://leetcode.cn/problems/subsets/description/

```java
List<List<Integer>> list = new ArrayList<>();

public List<List<Integer>> subsets(int[] nums) {
    int index = 0;
    List<Integer> temp = new ArrayList<>();
    backTrack(index, nums, temp);
    return list;
}

private void backTrack(int index, int[] nums, List<Integer> temp) {
    list.add(new ArrayList<>(temp));
    for (int i = index; i < nums.length; i++) {
        temp.add(nums[i]);
        backTrack(i + 1, nums, temp);
        temp.remove(temp.size() - 1);
    }
}
```

### 子集II 90

https://leetcode.cn/problems/subsets-ii/

```java
List<List<Integer>> list = new ArrayList<>();

public List<List<Integer>> subsetsWithDup(int[] nums) {
    int index = 0;
    List<Integer> temp = new ArrayList<>();
    Arrays.sort(nums);
    boolean[] used = new boolean[nums.length];
    backTrack(index, nums, temp, used);
    return list;
}

private void backTrack(int index, int[] nums, List<Integer> temp, boolean[] used) {
    list.add(new ArrayList<>(temp));
    for (int i = index; i < nums.length; i++) {
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        temp.add(nums[i]);
        used[i] = true;
        backTrack(i + 1, nums, temp, used);
        temp.remove(temp.size() - 1);
        used[i] = false;
    }
}
```

### 递增子序列 491

https://leetcode.cn/problems/non-decreasing-subsequences/

![递增子序列](../../../.vuepress/public/img\递增子序列.jpg)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracking(nums, 0);
        return result;
    }
    private void backTracking(int[] nums, int startIndex){
        if(path.size() >= 2)
                result.add(new ArrayList<>(path));            
        HashSet<Integer> hs = new HashSet<>();
        for(int i = startIndex; i < nums.length; i++){
            if(!path.isEmpty() && path.get(path.size() -1 ) > nums[i] || hs.contains(nums[i]))
                continue;
            hs.add(nums[i]);
            path.add(nums[i]);
            backTracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```



### 全排列 46

https://leetcode.cn/problems/permutations/

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> permute(int[] nums) {
    int index = 0;
    List<Integer> temp = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    backTrack(nums, temp, used);
    return res;
}

private void backTrack(int[] nums, List<Integer> temp, boolean[] used) {
    if (temp.size() == nums.length) {
        res.add(new ArrayList<>(temp));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) {
            continue;
        }
        temp.add(nums[i]);
        used[i] = true;
        backTrack(nums, temp, used);
        used[i] = false;
        temp.remove(temp.size() - 1);
    }
}
```

### 全排列 II 47

https://leetcode.cn/problems/permutations-ii/description/

```java
List<List<Integer>> res = new ArrayList<>();

public List<List<Integer>> permuteUnique(int[] nums) {
    List<Integer> temp = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    backTrack(nums, temp, used);
    return res;
}

private void backTrack(int[] nums, List<Integer> temp, boolean[] used) {
    if (temp.size() == nums.length) {
        res.add(new ArrayList<>(temp));
        return;
    }
    HashSet<Integer> hashSet = new HashSet<>();
    for (int i = 0; i < nums.length; i++) {
        if (used[i] || hashSet.contains(nums[i])) {
            continue;
        }
        hashSet.add(nums[i]);
        temp.add(nums[i]);
        used[i] = true;
        backTrack(nums, temp, used);
        used[i] = false;
        temp.remove(temp.size() - 1);
    }
}
```

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```

### 重新安排行程 332

https://leetcode.cn/problems/reconstruct-itinerary/

```java
private LinkedList<String> res;
private LinkedList<String> path = new LinkedList<>();

public List<String> findItinerary(List<List<String>> tickets) {
    Collections.sort(tickets, (a, b) -> a.get(1).compareTo(b.get(1)));
    path.add("JFK");
    boolean[] used = new boolean[tickets.size()];
    backTracking((ArrayList) tickets, used);
    return res;
}

public boolean backTracking(ArrayList<List<String>> tickets, boolean[] used) {
    if (path.size() == tickets.size() + 1) {
        res = new LinkedList(path);
        return true;
    }

    for (int i = 0; i < tickets.size(); i++) {
        if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
            path.add(tickets.get(i).get(1));
            used[i] = true;

            if (backTracking(tickets, used)) {
                return true;
            }

            used[i] = false;
            path.removeLast();
        }
    }
    return false;
}
```

```java
//key为起点，value是有序的终点的列表
Map<String, LinkedList<String>> ticketMap = new HashMap<>();
LinkedList<String> result = new LinkedList<>();
int total;

public List<String> findItinerary(List<List<String>> tickets) {
    total = tickets.size() + 1;
    //遍历tickets，存入ticketMap中
    for (List<String> ticket : tickets) {
        addNew(ticket.get(0), ticket.get(1));
    }
    deal("JFK");
    return result;
}

boolean deal(String currentLocation) {
    result.add(currentLocation);
    //机票全部用完，找到最小字符路径
    if (result.size() == total) {
        return true;
    }
    //当前位置的终点列表
    LinkedList<String> targetLocations = ticketMap.get(currentLocation);
    //没有从当前位置出发的机票了，说明这条路走不通
    if (targetLocations != null && !targetLocations.isEmpty()) {
        //终点列表中遍历到的终点
        String targetLocation;
        //遍历从当前位置出发的机票
        for (int i = 0; i < targetLocations.size(); i++) {
            //去重，否则在最后一个测试用例中遇到循环时会无限递归
            if(i > 0 && targetLocations.get(i).equals(targetLocations.get(i - 1))) continue;
            targetLocation = targetLocations.get(i);
            //删除终点列表中当前的终点
            targetLocations.remove(i);
            //递归
            if (deal(targetLocation)) {
                return true;
            }
            //路线走不通，将机票重新加回去
            targetLocations.add(i, targetLocation);
            result.removeLast();
        }
    }
    return false;
}

/**
     * 在map中按照字典顺序添加新元素
     *
     * @param start 起点
     * @param end   终点
     */
void addNew(String start, String end) {
    LinkedList<String> startAllEnd = ticketMap.getOrDefault(start, new LinkedList<>());
    if (!startAllEnd.isEmpty()) {
        for (int i = 0; i < startAllEnd.size(); i++) {
            if (end.compareTo(startAllEnd.get(i)) < 0) {
                startAllEnd.add(i, end);
                return;
            }
        }
        startAllEnd.add(startAllEnd.size(), end);
    } else {
        startAllEnd.add(end);
        ticketMap.put(start, startAllEnd);
    }
}
```



### N皇后 51

https://leetcode.cn/problems/n-queens/

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> solveNQueens(int n) {
    boolean[][] chess = new boolean[n][n];
    List<String> temp = new ArrayList<>();
    backTrack(0, n, chess, temp);
    return res;
}

private void backTrack(int row, int n, boolean[][] chess, List<String> temp) {
    if (row == n) {
        res.add(new ArrayList<>(temp));
        return;
    }
    for (int i = 0; i < n; i++) {
        // 检查第row行第i列能否放皇后
        if (check(row, i, chess)) {
            chess[row][i] = true;
            // 第i列放皇后
            temp.add(getQueenString(i, n));
            backTrack(row + 1, n, chess, temp);
            temp.remove(temp.size() - 1);
            chess[row][i] = false;
        }
    }
}

// 检查当前位置是否能放入
// 同一行 同一列 同一斜线 同一行上面代码已包括
private boolean check(int row, int col, boolean[][] chess) {
    // 列
    for (int i = 0; i < chess.length; i++) {
        if (i != row && chess[i][col]) {
            return false;
        }
    }
    // 斜线
    for (int i = 0; i < chess.length; i++) {
        for (int j = 0; j < chess.length; j++) {
            if (Math.abs(row - i) == Math.abs(col - j) && i != row && chess[i][j]) {
                return false;
            }
        }
    }

    return true;
}

private String getQueenString(int col, int n) {
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < n; i++) {
        if (i == col) {
            stringBuilder.append("Q");
        } else {
            stringBuilder.append(".");
        }
    }
    return stringBuilder.toString();
}
```

```java
List<List<String>> res = new ArrayList<>();

public List<List<String>> solveNQueens(int n) {
    char[][] chessboard = new char[n][n];
    for (char[] c : chessboard) {
        Arrays.fill(c, '.');
    }
    backTrack(n, 0, chessboard);
    return res;
}


public void backTrack(int n, int row, char[][] chessboard) {
    if (row == n) {
        res.add(Array2List(chessboard));
        return;
    }

    for (int col = 0;col < n; ++col) {
        if (isValid (row, col, n, chessboard)) {
            chessboard[row][col] = 'Q';
            backTrack(n, row+1, chessboard);
            chessboard[row][col] = '.';
        }
    }

}


public List Array2List(char[][] chessboard) {
    List<String> list = new ArrayList<>();

    for (char[] c : chessboard) {
        list.add(String.copyValueOf(c));
    }
    return list;
}


public boolean isValid(int row, int col, int n, char[][] chessboard) {
    // 检查列
    for (int i=0; i<row; ++i) { // 相当于剪枝
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }

    // 检查45度对角线
    for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }

    // 检查135度对角线
    for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
```



### 解数独 37

https://leetcode.cn/problems/sudoku-solver/

```java
public void solveSudoku(char[][] board) {
    solveSudokuHelper(board);
}

private boolean solveSudokuHelper(char[][] board){
    //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
    // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
    for (int i = 0; i < 9; i++){ // 遍历行
        for (int j = 0; j < 9; j++){ // 遍历列
            if (board[i][j] != '.'){ // 跳过原始数字
                continue;
            }
            for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                if (isValidSudoku(i, j, k, board)){
                    board[i][j] = k;
                    if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
                        return true;
                    }
                    board[i][j] = '.';
                }
            }
            // 9个数都试完了，都不行，那么就返回false
            return false;
            // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
            // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
        }
    }
    // 遍历完没有返回false，说明找到了合适棋盘位置了
    return true;
}

/**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
private boolean isValidSudoku(int row, int col, char val, char[][] board){
    // 同行是否重复
    for (int i = 0; i < 9; i++){
        if (board[row][i] == val){
            return false;
        }
    }
    // 同列是否重复
    for (int j = 0; j < 9; j++){
        if (board[j][col] == val){
            return false;
        }
    }
    // 9宫格里是否重复
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++){
        for (int j = startCol; j < startCol + 3; j++){
            if (board[i][j] == val){
                return false;
            }
        }
    }
    return true;
}
```



## 贪心算法

跳跃游戏 II 

K次取反后最大化的数组和

加油站 

合并区间

单调递增的数字

监控二叉树

### 分发饼干 455

https://leetcode.cn/problems/assign-cookies

**优先考虑饼干，小饼干先喂饱小胃口**

```java
public int findContentChildren(int[] g, int[] s) {
    int childIndex = 0;
    int cookIndex = 0;
    int max = 0;
    Arrays.sort(g);
    Arrays.sort(s);
    while (childIndex < g.length && cookIndex < s.length) {
        if (g[childIndex] <= s[cookIndex]) {
            max++;
            childIndex++;
        }
        cookIndex++;
    }
    return max;
}
```

```java
// 思路2：优先考虑胃口，先喂饱大胃口
public int findContentChildren(int[] g, int[] s) {
    Arrays.sort(g);
    Arrays.sort(s);
    int count = 0;
    int start = s.length - 1;
    // 遍历胃口
    for (int index = g.length - 1; index >= 0; index--) {
        if(start >= 0 && g[index] <= s[start]) {
            start--;
            count++;
        }
    }
    return count;
}
```

### 摆动序列

https://leetcode.cn/problems/wiggle-subsequence/
动态规划

```java
public int wiggleMaxLength(int[] nums) {
    // 以第i位置结尾的最长摆动序列 二维表示正负向摆动
    int[][] dp = new int[nums.length][2];
    for (int i = 0; i < dp.length; i++) {
        Arrays.fill(dp[i], 1);
    }
    // dp[i][0] = Math.max(dp[k][1] +1)  k<i  nums[i] > nums[k]
    // dp[i][1] = Math.max(dp[k][0] +1)  k<i  nums[i] < nums[k]
    for (int i = 1; i < nums.length; i++) {
        for (int k = 0; k < i; k++) {
            if (nums[i] > nums[k]) {
                dp[i][0] = Math.max(dp[k][1] + 1, dp[i][0]);
            }
            if (nums[i] < nums[k]) {
                dp[i][1] = Math.max(dp[k][0] + 1, dp[i][1]);
            }
            // 等于判断可省去
            if (nums[i] == nums[k]) {
                dp[i][0] = Math.max(dp[i][0], dp[k][0]);
                dp[i][1] = Math.max(dp[i][1], dp[k][1]);
            }
        }
    }
    return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
}
```

贪心 

![摆动序列](../../../.vuepress/public/img\摆动序列.jpg)

```java
public int wiggleMaxLength(int[] nums) {
    if (nums.length == 1) return 1;
    //up为第二元素大于第一元素序列长度，down相反
    int up = 1, down = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i-1]){
            up = down + 1;
        }else if (nums[i] < nums[i-1]){
            down = up + 1;
        }
    }
    return Math.max(up, down);
}
```

### 最大子序和 53

https://leetcode.cn/problems/maximum-subarray/

```java
public int maxSubArray(int[] nums) {
    // dp[i] 以i 结尾的最大和
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int max = nums[0];
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

### 买卖股票的最佳时机II 122

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/

**贪心 **

```java
public int maxProfit(int[] prices) {
    int sum = 0;
    for (int i = 1; i < prices.length; i++) {
        if (prices[i] - prices[i - 1] > 0) {
            sum += prices[i] - prices[i - 1];
        }
    }
    return sum;
}
```

**动态规划 **

```java
public int maxProfit(int[] prices) {
    int[][] dp = new int[prices.length][2];
    dp[0][0] = 0;
    dp[0][1] = -1 * prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][0]);
        dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
    }
     return dp[prices.length - 1][0];
}
```

### 跳跃游戏 55

 **贪心法**

```java
public boolean canJump(int[] nums) {
    int maxJump = 0;
    for (int i = 0; i < nums.length; i++) {
        if (i > maxJump) {
            return false;
        }
        maxJump = Math.max(maxJump, nums[i] + i);
        if (maxJump >= nums.length - 1) {
            return true;
        }
    }
    return false;
}
```

**动态规划**

dp[i]  为前i个位置能跳的最远距离

```java
public boolean canJump(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (i > dp[i - 1]) {
            return false;
        }
        dp[i] = Math.max(dp[i - 1], i + nums[i]);
        if (dp[i] >= nums.length - 1) {
            return true;
        }
    }
    return dp[nums.length - 1] >= nums.length - 1;
}
```

### 跳跃游戏 II 45

```java
public int jump(int[] nums) {
    if (nums == null || nums.length == 0 || nums.length == 1) {
        return 0;
    }
    //记录跳跃的次数
    int count=0;
    //当前的覆盖最大区域
    int curDistance = 0;
    //最大的覆盖区域
    int maxDistance = 0;
    for (int i = 0; i < nums.length; i++) {
        //在可覆盖区域内更新最大的覆盖区域
        maxDistance = Math.max(maxDistance,i+nums[i]);
        //说明当前一步，再跳一步就到达了末尾
        if (maxDistance>=nums.length-1){
            count++;
            break;
        }
        //走到当前覆盖的最大区域时，更新下一步可达的最大区域
        if (i==curDistance){
            curDistance = maxDistance;
            count++;
        }
    }
    return count;
}
```

### K次取反后最大化的数组和 1005

https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/

```java
public int largestSumAfterKNegations(int[] nums, int k) {
    Arrays.sort(nums);
    int index = 0;
    while (k > 0) {
        if (index < nums.length && nums[index] < 0) {
            nums[index++] *= -1;
            k--;
        } else {
            if (k % 2 != 0) {
                if (index==nums.length){
                    nums[index - 1] *= -1;
                } else if (index > 0 && nums[index] > nums[index - 1]) {
                    nums[index - 1] *= -1;
                } else {
                    nums[index] *= -1;
                }
            }
            break;
        }
    }
    return Arrays.stream(nums).sum();
}
```

```java
public int largestSumAfterKNegations(int[] nums, int k) {
           // list 转array int[] array = list.stream().mapToInt(Integer::intValue).toArray();
    	  // res.toArray(new Integer[0]) 转为Interger[]
         //  List<int[]> 转为 int[][] res.toArray(new int[0][])
    	 // array转list  List<Integer> collect = Arrays.stream(nums).boxed().collect(Collectors.toList());
        // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
        nums = Arrays.stream(nums)
                .boxed()
                .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
                .mapToInt(Integer::intValue)
                .toArray();
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            //从前向后遍历，遇到负数将其变为正数，同时K--
            if (nums[i] < 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }
        }
        // 如果K还大于0，那么反复转变数值最小的元素，将K用完
        if (k % 2 == 1) nums[len - 1] = -nums[len - 1];
        return Arrays.stream(nums).sum();
    }
```

### 加油站 134

https://leetcode.cn/problems/gas-station/

```json
有一个环形路上有n个站点； 每个站点都有一个好人或一个坏人； 好人会给你钱，坏人会收你一定的过路费，如果你带的钱不够付过路费，坏人会跳起来把你砍死； 问：从哪个站点出发，能绕一圈活着回到出发点?

首先考虑一种情况：如果全部好人给你 的钱加起来 小于 坏人收的过路费之和，那么总有一次你的钱不够付过路费，你的结局注定会被砍死。

假如你随机选一点 start 出发，那么你肯定会选一个有好人的站点开始，因为开始的时候你没有钱，遇到坏人只能被砍死；

现在你在start出发，走到了某个站点end，被end站点的坏人砍死了，说明你在 [start, end) 存的钱不够付 end点坏人的过路费，因为start站点是个好人，所以在 (start, end) 里任何一点出发，你存的钱会比现在还少，还是会被end站点的坏人砍死；

于是你重新读档，聪明的选择从 end+1点出发，继续你悲壮的征程； 终于有一天，你发现自己走到了尽头（下标是n-1)的站点而没有被砍死； 此时你犹豫了一下，那我继续往前走，身上的钱够不够你继续走到出发点Start?

当然可以，因为开始已经判断过，好人给你的钱数是大于等于坏人要的过路费的，你现在攒的钱完全可以应付 [0, start) 这一段坏人向你收的过路费。 这时候你的嘴角微微上扬，眼眶微微湿润，因为你已经知道这个世界的终极奥秘：Start就是这个问题的答案。
```

```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int total = 0;
    // 剩下的
    int cur = 0;
    // 起始位置
    int start = 0;
    for (int i = 0; i < gas.length; i++) {
        int leftGas = gas[i] - cost[i];
        total += leftGas;
        if (cur + gas[i] - cost[i] < 0) {
            cur = 0;
            start = i + 1;
        } else {
            cur += leftGas;
        }
    }
    return total >= 0 ? start : -1;
}
```

###  分发糖果 135

https://leetcode.cn/problems/candy/description/

```java
/**
         分两个阶段
         1、起点下标1 从左往右，只要 右边 比 左边 大，右边的糖果=左边 + 1
         2、起点下标 ratings.length - 2 从右往左， 只要左边 比 右边 大，此时 左边的糖果应该 取本身的糖果数（符合比它左边大） 和 右边糖果数 + 1 二者的最大值，这样才符合 它比它左边的大，也比它右边大
    */
public int candy(int[] ratings) {
    int len = ratings.length;
    int[] candyVec = new int[len];
    candyVec[0] = 1;
    for (int i = 1; i < len; i++) {
        candyVec[i] = (ratings[i] > ratings[i - 1]) ? candyVec[i - 1] + 1 : 1;
    }

    for (int i = len - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);
        }
    }

    int ans = 0;
    for (int num : candyVec) {
        ans += num;
    }
    return ans;
}
```

### 柠檬水找零 860

https://leetcode.cn/problems/lemonade-change/description/

```java
public boolean lemonadeChange(int[] bills) {
    int fiveCount = 0;
    int tenCount = 0;
    for (int i = 0; i < bills.length; i++) {
        if (bills[i] == 5) {
            fiveCount++;
        } else if (bills[i] == 10) {
            if (fiveCount == 0) {
                return false;
            }
            fiveCount--;
            tenCount++;
        } else if (bills[i] == 20) {
            if (tenCount > 0) {
                tenCount--;
                fiveCount--;
            } else {
                fiveCount -= 3;
            }
            if (fiveCount < 0) {
                return false;
            }
        }
    }
    return true;
}
```

### 根据身高重建队列 406

https://leetcode.cn/problems/queue-reconstruction-by-height/description/
 解题思路：先排序再插入
1.排序规则：按照先H高度降序，K个数升序排序
2.遍历排序后的数组，根据K插入到K的位置上

核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求


```java
public int[][] reconstructQueue(int[][] people) {
    Arrays.sort(people, (o1, o2) -> {
        if (o1[0] == o2[0]) {
            return o1[1] - o2[1];
        }
        return o2[0] - o1[0];
    });
    List<int[]> res = new ArrayList<>();
    for (int i = 0; i < people.length; i++) {
        if (people[i][1] == res.size()) {
            res.add(people[i]);
        } else {
            res.add(people[i][1], people[i]);
        }
    }
    return res.toArray(new int[0][]);
}
```

### 用最少数量的箭引爆气球 452

```java
public int findMinArrowShots(int[][] points) {
    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));
    long curMax = Long.MIN_VALUE;
    int count = 0;
    for (int i = 0; i < points.length; i++) {
        if (points[i][0] > curMax) {
            count++;
            curMax = points[i][1];
        }
    }
    return count;
}
```

### 无重叠区间 435

https://leetcode.cn/problems/non-overlapping-intervals

```java
public int eraseOverlapIntervals(int[][] intervals) {
    Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));
    int count = 0;
    int curMax = intervals[0][1];
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] < curMax) {
            count++;
        } else {
            curMax = intervals[i][1];
        }
    }
    return count;
}
```

### 划分字母区间

https://leetcode.cn/problems/partition-labels/

```java
public List<Integer> partitionLabels(String s) {
    int[] maxPosition = new int[26];
    for (int i = 0; i < s.length(); i++) {
        maxPosition[s.charAt(i) - 'a'] = i;
    }
    List<Integer> res = new ArrayList<>();
    int left = 0;
    // 能到达的最大位置
    int curMax = maxPosition[s.charAt(0) - 'a'];
    for (int i = 1; i < s.length(); i++) {
        int max = maxPosition[s.charAt(i) - 'a'];
        if (i > curMax) {
            curMax = max;
            res.add(i - left);
            left = i;
        } else {
            curMax = Math.max(curMax, max);
        }
    }
   // res.add(s.length() - res.stream().reduce(0, (a, b) -> a + b));
    res.add(s.length() - left);
    return res;
}
```

###  合并区间 56

https://leetcode.cn/problems/merge-intervals/description/

左排序

```java
public int[][] merge(int[][] intervals) {
    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
    int curMax = intervals[0][1];
    int left = intervals[0][0];
    List<int[]> res = new ArrayList<>();
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] <= curMax) {
            // 重叠
            left = Math.min(left, intervals[i][0]);
            curMax = Math.max(intervals[i][1], curMax);
        } else {
            res.add(new int[] { left, curMax });
            left = intervals[i][0];
            curMax = intervals[i][1];
        }
    }
    res.add(new int[] { left, curMax });
    return res.toArray(new int[0][]);
}
```

### 单调递增的数字 738

https://leetcode.cn/problems/monotone-increasing-digits/description/

![单调递增的数字](../../../.vuepress/public/img\单调递增的数字.jpg)

```java
public int monotoneIncreasingDigits(int n) {
    String s = String.valueOf(n);
    char[] chars = s.toCharArray();
    int start = s.length();
    for (int i = s.length() - 2; i >= 0; i--) {
        if (chars[i] > chars[i + 1]) {
            chars[i]--;
            start = i+1;
        }
    }
    for (int i = start; i < s.length(); i++) {
        chars[i] = '9';
    }
    return Integer.parseInt(String.valueOf(chars));
}
```

### 监控二叉树 968

https://leetcode.cn/problems/binary-tree-cameras

```java
int  res=0;
    public int minCameraCover(TreeNode root) {
        // 对根节点的状态做检验,防止根节点是无覆盖状态 .
        if(minCame(root)==0){
            res++;
        }
        return res;
    }
    /**
     节点的状态值：
       0 表示无覆盖
       1 表示 有摄像头
       2 表示有覆盖
    后序遍历，根据左右节点的情况,来判读 自己的状态
     */
    public int minCame(TreeNode root){
        if(root==null){
            // 空节点默认为 有覆盖状态，避免在叶子节点上放摄像头
            return 2;
        }
        int left=minCame(root.left);
        int  right=minCame(root.right);

        // 如果左右节点都覆盖了的话, 那么本节点的状态就应该是无覆盖,没有摄像头
        if(left==2&&right==2){
            //(2,2)
            return 0;
        }else if(left==0||right==0){
            // 左右节点都是无覆盖状态,那 根节点此时应该放一个摄像头
            // (0,0) (0,1) (0,2) (1,0) (2,0)
            // 状态值为 1 摄像头数 ++;
            res++;
            return 1;
        }else{
            // 左右节点的 状态为 (1,1) (1,2) (2,1) 也就是左右节点至少存在 1个摄像头，
            // 那么本节点就是处于被覆盖状态
            return 2;
        }
    }
```



## 动态规划

### 基础问题

#### 斐波那契数 509

https://leetcode.cn/problems/fibonacci-number/

```java
public int fib(int n) {
    if(n == 0 || n ==1 ){
        return n;
    }
    return fib(n-1) + fib(n-2);
}

public int fib(int n) {
    if (n <= 1) return n;             
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int index = 2; index <= n; index++){
        dp[index] = dp[index - 1] + dp[index - 2];
    }
    return dp[n];
}
```

#### 爬楼梯 70

https://leetcode.cn/problems/climbing-stairs/description/

```java
public int climbStairs(int n) {
    // dp[n] = dp[n-1] + dp[n-2]
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

#### 使用最小花费爬楼梯 746

https://leetcode.cn/problems/min-cost-climbing-stairs

```java
public int minCostClimbingStairs(int[] cost) {
    // dp[i] 到达i 所花费的最小价值
    // dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
    int[] dp = new int[cost.length + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i < dp.length; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[dp.length - 1];
}
```

#### 不同路径 62

https://leetcode.cn/problems/unique-paths/

```java
public int uniquePaths(int m, int n) {
    // dp[i][j] = dp[i-1][j] + dp[i][j-1]
    int[][] dp = new int[m][n];
    Arrays.fill(dp[0], 1);
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

状态压缩

```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
}
```

#### 不同路径 II 63

https://leetcode.cn/problems/unique-paths-ii/description/

```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];
    boolean rowFlag = false;
    boolean colFlag = false;
    for (int i = 0; i < m; i++) {
        if (rowFlag) {
            dp[i][0] = 0;
            continue;
        }
        if (obstacleGrid[i][0] == 1) {
            rowFlag = true;
            dp[i][0] = 0;
            continue;
        }
        dp[i][0] = 1;
    }
    for (int i = 0; i < n; i++) {
        if (colFlag) {
            dp[0][i] = 0;
            continue;
        }
        if (obstacleGrid[0][i] == 1) {
            colFlag = true;
            dp[0][i] = 0;
            continue;
        }
        dp[0][i] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (obstacleGrid[i][j] == 1) {
                dp[i][j] = 0;
                continue;
            }
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

#### 整数拆分 343

https://leetcode.cn/problems/integer-break/description/

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

```java
public int integerBreak(int n) {
    int[] dp = new int[n + 1];
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            dp[i] = Math.max(dp[i], j * Math.max(dp[i - j], i - j));
        }
    }
    return dp[n];
}
```

#### 不同的二叉搜索树

![不同的二叉搜索树](../../../.vuepress/public/img\不同的二叉搜索树.jpg)https://leetcode.cn/problems/unique-binary-search-trees/description/

```java
// dp[i] ：i个不同元素节点组成的二叉搜索树的个数
public int numTrees(int n) {
    //初始化 dp 数组
    int[] dp = new int[n + 1];
    //初始化0个节点和1个节点的情况
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
            //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}
```
### 背包问题
#### 0-1背包

![0-1背包](../../../.vuepress/public/img\0-1背包.jpg)

```java
public class BagProblem {
    public static void main(String[] args) {
        int[] weight = {1,3,4};
        int[] value = {15,20,30};
        int bagSize = 4;
        testWeightBagProblem(weight,value,bagSize);
    }

    /**
     * 动态规划获得结果
     * @param weight  物品的重量
     * @param value   物品的价值
     * @param bagSize 背包的容量
     */
    public static void testWeightBagProblem(int[] weight, int[] value, int bagSize){

        // 创建dp数组
        int goods = weight.length;  // 获取物品的数量
        int[][] dp = new int[goods][bagSize + 1];

        // 初始化dp数组
        // 创建数组后，其中默认的值就是0
        for (int j = weight[0]; j <= bagSize; j++) {
            dp[0][j] = value[0];
        }

        // 填充dp数组
        for (int i = 1; i < weight.length; i++) {
            for (int j = 1; j <= bagSize; j++) {
                if (j < weight[i]) {
                    /**
                     * 当前背包的容量都没有当前物品i大的时候，是不放物品i的
                     * 那么前i-1个物品能放下的最大价值就是当前情况的最大价值
                     */
                    dp[i][j] = dp[i-1][j];
                } else {
                    /**
                     * 当前背包的容量可以放下物品i
                     * 那么此时分两种情况：
                     *    1、不放物品i
                     *    2、放物品i
                     * 比较这两种情况下，哪种背包中物品的最大价值最大
                     */
                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);
                }
            }
        }

        // 打印dp数组
        for (int i = 0; i < goods; i++) {
            for (int j = 0; j <= bagSize; j++) {
                System.out.print(dp[i][j] + "\t");
            }
            System.out.println("\n");
        }
    }
}
```

降维优化

```java
public static void main(String[] args) {
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWight = 4;
    testWeightBagProblem(weight, value, bagWight);
}

public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight){
    int wLen = weight.length;
    //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值
    int[] dp = new int[bagWeight + 1];
    //遍历顺序：先遍历物品，再遍历背包容量
    for (int i = 0; i < wLen; i++){
        for (int j = bagWeight; j >= weight[i]; j--){
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    //打印dp数组
    for (int j = 0; j <= bagWeight; j++){
        System.out.print(dp[j] + " ");
    }
}
```

#### 分割等和子集 416

https://leetcode.cn/problems/partition-equal-subset-sum/description/

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

```java
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) {
        return false;
    }
    sum /= 2;
    //从物品中算出和为sum的最大价值
    int[][] dp = new int[nums.length][sum + 1];
    for (int i = 0; i <= sum; i++) {
        if (i >= nums[0]) {
            dp[0][i] = nums[0];
        }
    }
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j <= sum; j++) {
            if (j < nums[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]);
            }
        }
    }
    return dp[nums.length - 1][sum] == sum;
}
```

```java
public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    if (sum % 2 != 0) {
        return false;
    }
    sum /= 2;
    int[] dp = new int[sum + 1];
    for (int i = 0; i < dp.length; i++) {
        if (dp[i] >= nums[0]) {
            dp[i] = nums[0];
        }
    }
    for (int i = 1; i < nums.length; i++) {
        for (int j = sum; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
    return dp[sum] == sum;
}
```



#### 最后一块石头的重量 II 1049

https://leetcode.cn/problems/last-stone-weight-ii/description/

```java
public int lastStoneWeightII(int[] stones) {
    int sum = Arrays.stream(stones).sum();
    int halfSum = sum / 2;
    int[] dp = new int[halfSum + 1];
    for (int i = 0; i < stones.length; i++) {
        for (int j = halfSum; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
        }
    }
    return sum - dp[halfSum] * 2;
}
```

#### 目标和 494

```java
int count = 0;

public int findTargetSumWays(int[] nums, int target) {
    int index = 0;
    int tempSum = 0;
    backTrack(index, nums, tempSum, target);
    return count;
}

private void backTrack(int index, int[] nums, int tempSum, int target) {
    if (index == nums.length) {
        if (tempSum == target) {
            count++;
        }
        return;
    }
    // 不选当前位置
    backTrack(index + 1, nums, tempSum - nums[index], target);
    // 选当前位置
    backTrack(index + 1, nums, tempSum + nums[index], target);
}
```

```java
public int findTargetSumWays(int[] nums, int target) {
    // -a + b =target a + b = sum
    int sum = Arrays.stream(nums).sum();
    int twoPositiveSum = target + sum;
    if (twoPositiveSum % 2 != 0) {
        return 0;
    }
    target = twoPositiveSum / 2;
    if (target < 0) {
        return 0;
    }
    // dp[i][j] 从0-i 个物品选出数值为j的方法数
    // dp[i][j] = dp[i-1][j] + dp[i-1][j-num[i]]
    int[][] dp = new int[nums.length][target + 1];
    dp[0][0] = 1;
    for (int i = 0; i <= target; i++) {
        if (nums[0] == i) {
            dp[0][i] += 1;
        }
    }
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j <= target; j++) {
            if (j >= nums[i]) {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[nums.length - 1][target];
}
```

```java
public int findTargetSumWays(int[] nums, int target) {
    int sum = 0;
    for (int i = 0; i < nums.length; i++) sum += nums[i];

    //如果target的绝对值大于sum，那么是没有方案的
    if (Math.abs(target) > sum) return 0;
    //如果(target+sum)除以2的余数不为0，也是没有方案的
    if ((target + sum) % 2 == 1) return 0;

    int bagSize = (target + sum) / 2;
    int[] dp = new int[bagSize + 1];
    dp[0] = 1;

    for (int i = 0; i < nums.length; i++) {
        for (int j = bagSize; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }

    return dp[bagSize];
}
```

#### 一和零 474

https://leetcode.cn/problems/ones-and-zeroes/

回溯 超时

```java
class Solution {
    List<String> res = new ArrayList<>();
    int maxCount = 0;
    // 最终的子集字符串
    List<String> formList = new ArrayList<>();

    public int findMaxForm(String[] strs, int m, int n) {
        int oneCount = 0;
        int zeroCount = 0;
        int index = 0;
        backTrack(index, res, oneCount, zeroCount, strs, m, n);
        return maxCount;
    }

    private void backTrack(int index, List<String> res, int oneCount, int zeroCount, String[] strs, int m, int n) {
        if (oneCount > n || zeroCount > m || index == strs.length) {
            return;
        }
        for (int i = index; i < strs.length; i++) {
            String str = strs[i];
            int zeroStrCount = getZeroCount(str);
            int oneStrCount = str.length() - zeroStrCount;
            if (oneCount + oneStrCount > n || zeroStrCount + zeroCount > m) {
                continue;
            }
            res.add(str);
            if (res.size() > maxCount) {
                maxCount = res.size();
                formList = new ArrayList<>(res);
            }
            backTrack(i + 1, res, oneCount + oneStrCount, zeroStrCount + zeroCount, strs, m, n);
            res.remove(res.size() - 1);
        }
    }

    private int getZeroCount(String str) {
        int count = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == '0') {
                count++;
            }
        }
        return count;
    }
}
```

```java
public int findMaxForm(String[] strs, int m, int n) {
    int[][][] dp = new int[strs.length][m + 1][n + 1];
    int zeroCount = getZeroCount(strs[0]);
    int oneCount = strs[0].length() - zeroCount;
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (j >= oneCount && i >= zeroCount) {
                dp[0][i][j] = 1;
            }
        }
    }
    for (int i = 1; i < strs.length; i++) {
        int zeroStrCount = getZeroCount(strs[i]);
        int oneStrCount = strs[i].length() - zeroStrCount;
        for (int j = 0; j <= m; j++) {
            for (int k = 0; k <= n; k++) {
                if (j >= zeroStrCount && k >= oneStrCount) {
                    dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeroStrCount][k - oneStrCount]+1);

                } else {
                    dp[i][j][k] = dp[i - 1][j][k];
                }
            }
        }
    }
    return dp[strs.length - 1][m][n];
}

private int getZeroCount(String str) {
    int count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '0') {
            count++;
        }
    }
    return count;
}
```

降维

```java
public int findMaxForm(String[] strs, int m, int n) {
    int[][] dp = new int[m + 1][n + 1];
    dp[0][0] = 0;
    for (int i = 0; i < strs.length; i++) {
        int zeroStrCount = getZeroCount(strs[i]);
        int oneStrCount = strs[i].length() - zeroStrCount;
        for (int j = m; j >= zeroStrCount; j--) {
            for (int k = n; k >= oneStrCount; k--) {
                dp[j][k] = Math.max(dp[j][k], dp[j - zeroStrCount][k - oneStrCount] + 1);
            }
        }
    }
    return dp[m][n];
}


private int getZeroCount(String str) {
    int count = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '0') {
            count++;
        }
    }
    return count;
}
```

#### 完全背包

![完全背包](../../../.vuepress/public/img\完全背包.jpg)

![完全背包1](../../../.vuepress/public/img\完全背包1.jpg)对于纯完全背包，先遍历物品，再遍历背包 与 先遍历背包，再遍历物品都是可以的

- 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

```java
//先遍历物品，再遍历背包
private static void testCompletePack(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 0; i < weight.length; i++){ // 遍历物品
        for (int j = weight[i]; j <= bagWeight; j++){ // 遍历背包容量
            dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}

//先遍历背包，再遍历物品
private static void testCompletePackAnotherWay(){
    int[] weight = {1, 3, 4};
    int[] value = {15, 20, 30};
    int bagWeight = 4;
    int[] dp = new int[bagWeight + 1];
    for (int i = 1; i <= bagWeight; i++){ // 遍历背包容量
        for (int j = 0; j < weight.length; j++){ // 遍历物品
            if (i - weight[j] >= 0){
                dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
            }
        }
    }
    for (int maxValue : dp){
        System.out.println(maxValue + "   ");
    }
}
```

#### 零钱兑换II 518

https://leetcode.cn/problems/coin-change-ii/

```java
public int change(int amount, int[] coins) {
    int[][] dp = new int[coins.length][amount+1];

    // 初始化边界值
    for(int i = 0; i < coins.length; i++){
        // 什么都不取
        // 第一列的初始值为1
        dp[i][0] = 1;
    }
    for(int j = coins[0]; j <= amount; j += coins[0]){
        // 初始化第一行
        dp[0][j] = 1;
    }

    for(int i = 1; i < coins.length; i++){
        for(int j = 1; j <= amount; j++){
            if(j < coins[i]) dp[i][j] = dp[i-1][j];
            else dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j];
        }
    }

    return dp[coins.length-1][amount];
}
```

```java
public int change(int amount, int[] coins) {
    //递推表达式
    int[] dp = new int[amount + 1];
    //初始化dp数组，表示金额为0时只有一种情况，也就是什么都不装
    dp[0] = 1;
    for (int i = 0; i < coins.length; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] += dp[j - coins[i]];
        }
    }
    return dp[amount];
}
```

#### 组合总和 Ⅳ 377

https://leetcode.cn/problems/combination-sum-iv/

```java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (i >= nums[j]) {
                dp[i] = dp[i] + dp[i - nums[j]];
            }
        }
    }
    return dp[target];
}
```

#### 爬楼梯（进阶版）

https://kamacoder.com/problempage.php?pid=1067

1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。

```java
import java.util.Scanner;
class climbStairs{
    public static void main(String [] args){
        Scanner sc = new Scanner(System.in);
        int m, n;
        while (sc.hasNextInt()) {
            // 从键盘输入参数，中间用空格隔开
            n = sc.nextInt();
            m = sc.nextInt();
            // 求排列问题，先遍历背包再遍历物品
            int[] dp = new int[n + 1];
            dp[0] = 1;
            for (int j = 1; j <= n; j++) {
                for (int i = 1; i <= m; i++) {
                    if (j - i >= 0) dp[j] += dp[j - i];
                }
            }
            System.out.println(dp[n]);
        }
    }
}
```

#### 零钱兑换 322

https://leetcode.cn/problems/coin-change/

**本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。

```java
public int coinChange(int[] coins, int amount) {
    int max = Integer.MAX_VALUE;
    int[] dp = new int[amount + 1];
    //初始化dp数组为最大值
    for (int j = 0; j < dp.length; j++) {
        dp[j] = max;
    }
    //当金额为0时需要的硬币数目为0
    dp[0] = 0;
    for (int i = 0; i < coins.length; i++) {
        //正序遍历：完全背包每个硬币可以选择多次
        for (int j = coins[i]; j <= amount; j++) {
            //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要
            if (dp[j - coins[i]] != max) {
                //选择硬币数目最小的情况
                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
    }
    return dp[amount] == max ? -1 : dp[amount];
}
```

#### 完全平方数 279

https://leetcode.cn/problems/perfect-squares/

**dp[j]：和为j的完全平方数的最少数量为dp[j]**

```java
class Solution {
    // 版本一，先遍历物品, 再遍历背包
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        //初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        //如果不想要寫for-loop填充數組的話，也可以用JAVA內建的Arrays.fill()函數。
        //Arrays.fill(dp, Integer.MAX_VALUE);

        //当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历物品
        for (int i = 1; i * i <= n; i++) {
            // 遍历背包
            for (int j = i * i; j <= n; j++) {
                //if (dp[j - i * i] != max) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
                //}
                //不需要這個if statement，因爲在完全平方數這一題不會有"湊不成"的狀況發生（ 一定可以用"1"來組成任何一個n），故comment掉這個if statement。
            }
        }
        return dp[n];
    }
}

class Solution {
    // 版本二， 先遍历背包, 再遍历物品
    public int numSquares(int n) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[n + 1];
        // 初始化
        for (int j = 0; j <= n; j++) {
            dp[j] = max;
        }
        // 当和为0时，组合的个数为0
        dp[0] = 0;
        // 遍历背包
        for (int j = 1; j <= n; j++) {
            // 遍历物品
            for (int i = 1; i * i <= j; i++) {
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
```

#### 单词拆分 139

https://leetcode.cn/problems/word-break/

**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**

![单词拆分](../../../.vuepress/public/img\单词拆分.jpg)

```java
public boolean wordBreak(String s, List<String> wordDict) {
    HashSet<String> set = new HashSet<>(wordDict);
    boolean[] valid = new boolean[s.length() + 1];
    valid[0] = true;

    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i && !valid[i]; j++) {
            if (set.contains(s.substring(j, i)) && valid[j]) {
                valid[i] = true;
            }
        }
    }

    return valid[s.length()];
}
```

```java
public boolean wordBreak(String s, List<String> wordDict) {
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;

    for (int i = 1; i <= s.length(); i++) {
        for (String word : wordDict) {
            int len = word.length();
            if (i >= len && dp[i - len] && word.equals(s.substring(i - len, i))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[s.length()];
}
```

#### 多重背包

```java
public static void main(String [] args) {
    Scanner sc = new Scanner(System.in);

    /**
         * bagWeight:背包容量
         * n:物品种类
         */
    int bagWeight, n;

    //获取用户输入数据，中间用空格隔开，回车键换行
    bagWeight = sc.nextInt();
    n = sc.nextInt();
    int[] weight = new int[n];
    int[] value = new int[n];
    int[] nums = new int[n];
    for (int i = 0; i < n; i++) weight[i] = sc.nextInt();
    for (int i = 0; i < n; i++) value[i] = sc.nextInt();
    for (int i = 0; i < n; i++) nums[i] = sc.nextInt();

    int[] dp = new int[bagWeight + 1];

    //先遍历物品再遍历背包，作为01背包处理
    for (int i = 0; i < n; i++) {
        for (int j = bagWeight; j >= weight[i]; j--) {
            //遍历每种物品的个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) {
                dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
    }
    System.out.println(dp[bagWeight]);
}
```

###  打家劫舍

#### 打家劫舍 198

https://leetcode.cn/problems/house-robber/

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

```java
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    dp[1] = Math.max(dp[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    return dp[nums.length - 1];
}
```

```java
public int rob(int[] nums) {
    int[][] dp = new int[nums.length + 1][2];
    dp[0][0] = 0;
    dp[0][1] = 0;
    dp[1][0] = 0;
    dp[1][1] = nums[0];
    for (int i = 2; i <= nums.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][1], Math.max(dp[i - 2][0], dp[i - 2][1]));
        dp[i][1] = Math.max(Math.max(dp[i - 2][0], dp[i - 2][1]), dp[i - 1][0]) + nums[i - 1];
    }
    return Math.max(dp[nums.length][0], dp[nums.length][1]);
}
```

#### 打家劫舍II 213

https://leetcode.cn/problems/house-robber-ii/description/

```java
public int rob(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }
    int[] robNums1 = Arrays.copyOfRange(nums, 0, nums.length - 1);
    int[] robNums2 = Arrays.copyOfRange(nums, 1, nums.length);
    return Math.max(robCircle(robNums1), robCircle(robNums2));
}

private int robCircle(int[] nums) {
    if (nums.length == 1) {
        return nums[0];
    }
    int[][] dp = new int[nums.length + 1][2];
    dp[0][0] = 0;
    dp[0][1] = 0;
    dp[1][0] = 0;
    dp[1][1] = nums[0];
    for (int i = 2; i <= nums.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][1], Math.max(dp[i - 2][0], dp[i - 2][1]));
        dp[i][1] = Math.max(Math.max(dp[i - 2][0], dp[i - 2][1]), dp[i - 1][0]) + nums[i - 1];
    }
    return Math.max(dp[nums.length][0], dp[nums.length][1]);
}
```

#### 打家劫舍III 317

树形dp

https://leetcode.cn/problems/house-robber-iii/description/

```java
public int rob(TreeNode root) {
    if (root == null)
        return 0;
    int money = root.val;
    if (root.left != null) {
        money += rob(root.left.left) + rob(root.left.right);
    }
    if (root.right != null) {
        money += rob(root.right.left) + rob(root.right.right);
    }
    return Math.max(money, rob(root.left) + rob(root.right));
}
```

```java
public int rob3(TreeNode root) {
    int[] res = robAction1(root);
    return Math.max(res[0], res[1]);
}

int[] robAction1(TreeNode root) {
    int res[] = new int[2];
    if (root == null)
        return res;

    int[] left = robAction1(root.left);
    int[] right = robAction1(root.right);

    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    res[1] = root.val + left[0] + right[0];
    return res;
}
```

### 买卖股票

#### 买卖股票的最佳时机 121 

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/

```java
public int maxProfit(int[] prices) {
    int pre = prices[0];
    int sell = 0;
    for (int i = 1; i < prices.length; i++) {
        pre = Math.min(prices[i], pre);
        sell = Math.max(sell, prices[i] - pre);
    }
    return sell;
}
```

```java
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) return 0;
    int length = prices.length;
    // dp[i][0]代表第i天持有股票的最大收益
    // dp[i][1]代表第i天不持有股票的最大收益
    int[][] dp = new int[length][2];
    int result = 0;
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    for (int i = 1; i < length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
        dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
    }
    return dp[length - 1][1];
}
```

```java
public int maxProfit(int[] prices) {
    int len = prices.length;
    int dp[][] = new int[2][2];

    dp[0][0] = - prices[0];
    dp[0][1] = 0;

    for (int i = 1; i < len; i++){
        dp[i % 2][0] = Math.max(dp[(i - 1) % 2][0], - prices[i]);
        dp[i % 2][1] = Math.max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
    }
    return dp[(len - 1) % 2][1];
}
```

#### 买卖股票的最佳时机II 122

 https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

```java
// 实现1：二维数组存储
// 可以将每天持有与否的情况分别用 dp[i][0] 和 dp[i][1] 来进行存储
// 时间复杂度：O(n)，空间复杂度：O(n)
public int maxProfit(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];     // 创建二维数组存储状态
    dp[0][0] = 0;                   // 初始状态
    dp[0][1] = -prices[0];
    for (int i = 1; i < n; ++i) {
        // 那么再次股票交易时，要加上之前的收益
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    // 第 i 天，没有股票
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    // 第 i 天，持有股票
    }
    return dp[n - 1][0];    // 卖出股票收益高于持有股票收益，因此取[0]
}
```

#### 买卖股票的最佳时机III 123

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/

```java
public int maxProfit(int[] prices) {
    int len = prices.length;
    // 边界判断, 题目中 length >= 1, 所以可省去
    if (prices.length == 0) return 0;

    	/*
         * 定义 5 种状态:
         * 0: 没有操作, 1: 第一次买入, 2: 第一次卖出, 3: 第二次买入, 4: 第二次卖出
         */
    int[][] dp = new int[len][5];
    dp[0][1] = -prices[0];
    // 初始化第二次买入的状态是确保 最后结果是最多两次买卖的最大利润
    dp[0][3] = -prices[0];

    for (int i = 1; i < len; i++) {
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    }

    return dp[len - 1][4];
}
```

#### 买卖股票的最佳时机IV

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/

```java
public int maxProfit(int k, int[] prices) {
    if (prices.length == 0) return 0;

    // [天数][交易次数][是否持有股票]
    int len = prices.length;
    int[][][] dp = new int[len][k + 1][2];
    // dp数组初始化
    // 初始化所有的交易次数是为确保 最后结果是最多 k 次买卖的最大利润
    for (int i = 0; i <= k; i++) {
        dp[0][i][1] = -prices[0];
    }
    for (int i = 1; i < len; i++) {
        for (int j = 1; j <= k; j++) {
            // dp方程, 0表示不持有/卖出, 1表示持有/买入
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
    return dp[len - 1][k][0];
}
```

```java
public int maxProfit(int k, int[] prices) {
    if (prices.length == 0) return 0;

    // [天数][股票状态]
    // 股票状态: 奇数表示第 k 次交易持有/买入, 偶数表示第 k 次交易不持有/卖出, 0 表示没有操作
    int len = prices.length;
    int[][] dp = new int[len][k*2 + 1];

    // dp数组的初始化, 与版本一同理
    for (int i = 1; i < k*2; i += 2) {
        dp[0][i] = -prices[0];
    }

    for (int i = 1; i < len; i++) {
        for (int j = 0; j < k*2 - 1; j += 2) {
            dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
            dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
        }
    }
    return dp[len - 1][k*2];
}
```

#### 最佳买卖股票时机含冷冻期 309

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/

![买卖股票](../../../.vuepress/public/img\买卖股票.jpg)

- 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
- 不持有股票状态，这里就有两种卖出股票状态
  - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  - 状态三：今天卖出股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

```c++
int maxProfit(vector<int>& prices) {
    int n = prices.size();
    if (n == 0) return 0;
    vector<vector<int>> dp(n, vector<int>(4, 0));
    dp[0][0] -= prices[0]; // 持股票
    for (int i = 1; i < n; i++) {
        dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
        dp[i][2] = dp[i - 1][0] + prices[i];
        dp[i][3] = dp[i - 1][2];
    }
    return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));
}
```

#### 买卖股票的最佳时机含手续费 714

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/

```java
public int maxProfit(int[] prices, int fee) {
    // 买入时扣除手续费
    int[][] dp = new int[prices.length][2];
    dp[0][0] = 0;
    dp[0][1] = -1 * fee - prices[0]; // 持有股票
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
    }
    return dp[prices.length - 1][0];
}
```

```java
public int maxProfit(int[] prices, int fee) {
    int len = prices.length;
    // 0 : 持股（买入）
    // 1 : 不持股（售出）
    // dp 定义第i天持股/不持股 所得最多现金
    int[][] dp = new int[len][2];
    dp[0][0] = -prices[0];
    for (int i = 1; i < len; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]);
    }
    return Math.max(dp[len - 1][0], dp[len - 1][1]);
}
```

### 子序列问题

#### 最长递增子序列 300 

https://leetcode.cn/problems/longest-increasing-subsequence/

```java
public int lengthOfLIS(int[] nums) {
    // dp[i] 以nums[i] 结尾的最大子序列的长度
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);
    int max = 1;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

#### 最长连续递增序列 674

https://leetcode.cn/problems/longest-continuous-increasing-subsequence/

```java
public int findLengthOfLCIS(int[] nums) {
    int max = 1;
    int left = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] <= nums[i - 1]) {
            max = Math.max(max, i - left);
            left = i;
        }
    }
    return Math.max(max, nums.length - left);
}
```

```java
public int findLengthOfLCIS(int[] nums) {
    int[] dp = new int[nums.length];
    int max = 1;
    Arrays.fill(dp, 1);
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1]) {
            dp[i] = dp[i - 1] + 1;
        }
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

#### 最长重复子数组 718

https://leetcode.cn/problems/maximum-length-of-repeated-subarray/

```java
public int findLength(int[] nums1, int[] nums2) {
    int max = 0;
    int[][] dp = new int[nums1.length + 1][nums2.length + 1];
    for (int i = 1; i <= nums1.length; i++) {
        for (int j = 1; j <= nums2.length; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
            }
            max = Math.max(max, dp[i][j]);
        }
    }
    return max;
}
```

```java
public int findLength(int[] nums1, int[] nums2) {
    int[] dp = new int[nums2.length + 1];
    int result = 0;

    for (int i = 1; i <= nums1.length; i++) {
        for (int j = nums2.length; j > 0; j--) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[j] = dp[j - 1] + 1;
            } else {
                dp[j] = 0;
            }
            result = Math.max(result, dp[j]);
        }
    }
    return result;
}
```

#### 最长公共子序列 1143

https://leetcode.cn/problems/longest-common-subsequence/

```java
public int longestCommonSubsequence(String text1, String text2) {
    int length1 = text1.length();
    int length2 = text2.length();
    int[][] dp = new int[length1 + 1][length2 + 1];
    for (int i = 1; i < text1.length() + 1; i++) {
        char char1 = text1.charAt(i-1);
        for (int j = 1; j < text2.length() + 1; j++) {
            char char2 = text2.charAt(j-1);
            if (char1 == char2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[length1][length2];
}
```

#### 不相交的线 1035

https://leetcode.cn/problems/uncrossed-lines/description/

```java
public int maxUncrossedLines(int[] nums1, int[] nums2) {
    int length1 = nums1.length;
    int length2 = nums2.length;
    int[][] dp = new int[length1 + 1][length2 + 1];
    for (int i = 1; i < length1 + 1; i++) {
        int pointX = nums1[i-1];
        for (int j = 1; j < length2 + 1; j++) {
            int pointY = nums2[j-1];
            if (pointX == pointY) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[length1][length2];
}
```

#### 最大子序和 53

https://leetcode.cn/problems/maximum-subarray/description/

```java
public int maxSubArray(int[] nums) {
    // dp[i] 以i 结尾的最大和
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int max = nums[0];
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        max = Math.max(max, dp[i]);
    }
    return max;
}
```

#### 判断子序列 392

https://leetcode.cn/problems/is-subsequence/

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

![判断子序列](../../../.vuepress/public/img\判断子序列.jpg)

```java
public boolean isSubsequence(String s, String t) {
    int n = s.length(), m = t.length();
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (s.charAt(i) == t.charAt(j)) {
            i++;
        }
        j++;
    }
    return i == n;
}
```

**dp[i\][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i\][j]**

```java
public boolean isSubsequence(String s, String t) {
    int length1 = s.length(); int length2 = t.length();
    int[][] dp = new int[length1+1][length2+1];
    for(int i = 1; i <= length1; i++){
        for(int j = 1; j <= length2; j++){
            if(s.charAt(i-1) == t.charAt(j-1)){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = dp[i][j-1];
            }
        }
    }
    if(dp[length1][length2] == length1){
        return true;
    }else{
        return false;
    }
}
```

#### 不同的子序列 115

https://leetcode.cn/problems/distinct-subsequences/description/

dp[i\][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i\][j]初始化



dp[i\][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

那么dp[i\][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。

再来看dp[0\][j]，dp[0\][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。

那么dp[0\][j]一定都是0，s如论如何也变成不了t。

```java
public int numDistinct(String s, String t) {
    int[][] dp = new int[s.length() + 1][t.length() + 1];
    for (int i = 0; i < s.length() + 1; i++) {
        dp[i][0] = 1;
    }

    for (int i = 1; i < s.length() + 1; i++) {
        for (int j = 1; j < t.length() + 1; j++) {
            if (s.charAt(i - 1) == t.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            }else{
                // 相当于删除 s[i-1]
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[s.length()][t.length()];
}
```

#### 两个字符串的删除操作 583

https://leetcode.cn/problems/delete-operation-for-two-strings/description/

```java
//dp数组中存储word1和word2最长相同子序列的长度
public int minDistance(String word1, String word2) {
    int len1 = word1.length();
    int len2 = word2.length();
    int[][] dp = new int[len1 + 1][len2 + 1];

    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return len1 + len2 - dp[len1][len2] * 2;
}
```

```java
// dp数组中存储需要删除的字符个数
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp = new int[word1.length() + 1][word2.length() + 1];
        for (int i = 0; i < word1.length() + 1; i++) dp[i][0] = i;
        for (int j = 0; j < word2.length() + 1; j++) dp[0][j] = j;

        for (int i = 1; i < word1.length() + 1; i++) {
            for (int j = 1; j < word2.length() + 1; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }else{
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,
                                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }

        return dp[word1.length()][word2.length()];
    }
}
```

#### 编辑距离 72

https://leetcode.cn/problems/edit-distance/

**dp[i\][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i\][j]**

![编辑距离](../../../.vuepress/public/img\编辑距离.jpg)

![编辑距离1](../../../.vuepress/public/img\编辑距离1.jpg)

```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    int[][] dp = new int[m + 1][n + 1];
    // 初始化
    for (int i = 1; i <= m; i++) {
        dp[i][0] =  i;
    }
    for (int j = 1; j <= n; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            // 因为dp数组有效位从1开始
            // 所以当前遍历到的字符串的位置为i-1 | j-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 编辑 增加 减少
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
    }
    return dp[m][n];
}
```

#### 回文子串 647 

https://leetcode.cn/problems/palindromic-substrings/

```java
public int countSubstrings(String s) {
    char[] chars = s.toCharArray();
    int len = chars.length;
    boolean[][] dp = new boolean[len][len];
    int result = 0;
    for (int i = len - 1; i >= 0; i--) {
        for (int j = i; j < len; j++) {
            if (chars[i] == chars[j]) {
                if (j - i <= 1) { // 情况一 和 情况二
                    result++;
                    dp[i][j] = true;
                } else if (dp[i + 1][j - 1]) { //情况三
                    result++;
                    dp[i][j] = true;
                }
            }
        }
    }
    return result;
}
```

#### 最长回文子序列 516

https://leetcode.cn/problems/longest-palindromic-subsequence/

**dp[i\][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i\][j]**

```java
public int longestPalindromeSubseq(String s) {
    int len = s.length();
    int[][] dp = new int[len + 1][len + 1];
    for (int i = len - 1; i >= 0; i--) { // 从后往前遍历 保证情况不漏
        dp[i][i] = 1; // 初始化
        for (int j = i + 1; j < len; j++) {
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));
            }
        }
    }
    return dp[0][len - 1];
}
```



##  单调栈

### 每日温度 739

https://leetcode.cn/problems/daily-temperatures/description/https://leetcode.cn/problems/last-stone-weight-ii/description/

维护一个单调递减的栈  能找到下一个比当前大的数

```java
public int[] dailyTemperatures(int[] temperatures) {
    int[] res = new int[temperatures.length];
    Arrays.fill(res, 0);
    // 维护一个单调递减的栈
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < temperatures.length; i++) {
        while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
            Integer pop = stack.pop();
            res[pop] = i - pop;
        }
        stack.push(i);
    }
    return res;
}
```

### 下一个更大元素I 496

https://leetcode.cn/problems/next-greater-element-i/description/

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    int[] res = new int[nums1.length];
    Arrays.fill(res, -1);
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < nums2.length; i++) {
        while (!stack.isEmpty() && nums2[i] > nums2[stack.peek()]) {
            Integer pop = stack.pop();
            // 判断pop出的元素是否在num1存在
            int index = getIndex(nums1, nums2[pop]);
            if (index != -1) {
                res[index] = nums2[i];
            }
        }
        stack.push(i);
    }
    return res;
}

private int getIndex(int[] nums1, int i) {
    for (int j = 0; j < nums1.length; j++) {
        if (nums1[j] == i) {
            return j;
        }
    }
    return -1;
}
```

### 下一个更大元素II 503

https://leetcode.cn/problems/next-greater-element-ii/

```java
class Solution {
public int[] nextGreaterElements(int[] nums) {
        int[] nums_double = new int[nums.length * 2];
        int[] res = new int[nums.length];
        Arrays.fill(res, -1);
        for (int i = 0; i < nums_double.length; i++) {
            nums_double[i] = nums[i % nums.length];
        }
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < nums_double.length; i++) {
            while (!stack.isEmpty() && nums_double[i] > nums_double[stack.peek()]) {
                int pop = stack.pop() % nums.length;
                if (res[pop] == -1) {
                    res[pop] = nums[i % nums.length];
                }
            }
            stack.push(i);
        }
        return res;
    }
}
```

###  接雨水

https://leetcode.cn/problems/trapping-rain-water/description/

```java
public int trap(int[] height) {
    int sum = 0;
    // 维护一个单调递减的栈
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < height.length; i++) {
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            Integer pop = stack.pop();
            if (!stack.isEmpty()) {
                sum += (Math.min(height[stack.peek()], height[i]) - height[pop]) * (i - stack.peek() - 1);
            }
        }
        stack.push(i);
    }
    return sum;
}
```

### 柱状图中最大的矩形 84

https://leetcode.cn/problems/largest-rectangle-in-histogram/description/

```java
public int largestRectangleArea(int[] heights) {
    int[] newHeights = new int[heights.length + 2];
    newHeights[0] = -1;
    for (int i = 0; i < heights.length; i++) {
        newHeights[i + 1] = heights[i];
    }
    newHeights[newHeights.length - 1] = -1;
    int area = 0;
    // 维护一个单调递增的栈
    // 左边是小于当前的高度  找到右边小于自己高度的位置
    //即中间全部的高度都是大于等于自己的高度 面积就以自己为高 宽度即左右小于自己高度距离-2
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < newHeights.length; i++) {
        while (!stack.isEmpty() && newHeights[stack.peek()] > newHeights[i]) {
            int pop = stack.pop();
            int height = newHeights[pop];
            if (!stack.isEmpty()) {
                int left = stack.peek();
                area = Math.max(area, height * (i - left - 1));
            }
        }
        stack.push(i);
    }
    return area;
}
```

## 图论

### 深度优先模板

```java
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

### 广度优先模板

```java
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

### 所有可能的路径 797

https://leetcode.cn/problems/all-paths-from-source-to-target/description/

```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> path = new ArrayList<Integer>();
        path.add(0);
        helper(0, path, res, graph);
        return res;
    }

    // 回溯算法求解
    private void helper(int index, List<Integer> path, List<List<Integer>> res, int[][] graph) {
        if (graph.length - 1 == index) {
            res.add(new ArrayList<Integer>(path));
            return;
        }
        int[] dresses = graph[index];
        for (int i = 0; i < dresses.length; i++) {
            path.add(dresses[i]);
            helper(dresses[i], path, res, graph);
            path.remove(path.size() - 1);
        }
    }
}
```

```java

public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    // bfs，从0开始一层一层向外搜索
    List<List<Integer>> resultList = new ArrayList<>();

    int n = graph.length;
    Queue<Node> queue = new LinkedList<>();
    queue.offer(new Node(0));

    while (!queue.isEmpty()) {
        Node node = queue.poll();
        if (node.index == n - 1) {
            resultList.add(node.path);
            continue;
        }
        for (int next : graph[node.index]) {
            queue.offer(new Node(next, node.path));
        }
    }

    return resultList;
}

class Node {
    int index;
    List<Integer> path;

    Node(int index) {
        this.index = index;
        this.path = new ArrayList<>();
        // 把当前节点加入路径
        this.path.add(index);
    }

    Node(int index, List<Integer> path) {
        this.index = index;
        // 复制一个新的List
        this.path = new ArrayList<>(path);
        // 把当前节点加入路径
        this.path.add(index);
    }
}

```

### 岛屿数量

https://kamacoder.com/problempage.php?pid=1171

![岛屿数量](../../../.vuepress/public/img\岛屿数量.jpg)

```c++
#include <iostream>
#include <vector>
using namespace std;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    visited[x][y] = true; // 标记访问过
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        dfs(grid, visited, nextx, nexty);
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));

    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                result++; // 遇到没访问过的陆地，+1
                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
            }
        }
    }
    cout << result << endl;
}
```

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que;
    que.push({x, y});
    visited[x][y] = true; // 只要加入队列，立刻标记
    while(!que.empty()) {
        pair<int ,int> cur = que.front(); que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for (int i = 0; i < 4; i++) {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                que.push({nextx, nexty});
                visited[nextx][nexty] = true; // 只要加入队列立刻标记
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));

    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                result++; // 遇到没访问过的陆地，+1
                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
            }
        }
    }


    cout << result << endl;
}
```

### 岛屿的最大面积

https://kamacoder.com/problempage.php?pid=1172

```c++
// 版本二
#include <iostream>
#include <vector>
using namespace std;

int count;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    visited[x][y] = true; // 标记访问过
    count++;
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        dfs(grid, visited, nextx, nexty);
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                count = 0; // 因为dfs处理当前节点，所以遇到陆地计数为0，进dfs之后在开始从1计数
                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                result = max(result, count);
            }
        }
    }
    cout << result << endl;
}
```

```c++
class Solution {
private:
    int count;
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<int> que;
        que.push(x);
        que.push(y);
        visited[x][y] = true; // 加入队列就意味节点是陆地可到达的点
        count++;
        while(!que.empty()) {
            int xx = que.front();que.pop();
            int yy = que.front();que.pop();
            for (int i = 0 ;i < 4; i++) {
                int nextx = xx + dir[i][0];
                int nexty = yy + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue; // 越界
                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 节点没有被访问过且是陆地
                    visited[nextx][nexty] = true;
                    count++;
                    que.push(nextx);
                    que.push(nexty);
                }
            }
        }
    }

public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    count = 0;
                    bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```

###  孤岛的总面积

https://kamacoder.com/problempage.php?pid=1173

![孤岛的面积](../../../.vuepress/public/img\孤岛的面积.jpg)

```c++
#include <iostream>
#include <vector>
using namespace std;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向
int count; // 统计符合题目要求的陆地空格数量
void dfs(vector<vector<int>>& grid, int x, int y) {
    grid[x][y] = 0;
    count++;
    for (int i = 0; i < 4; i++) { // 向四个方向遍历
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
        // 不符合条件，不继续遍历
        if (grid[nextx][nexty] == 0) continue;

        dfs (grid, nextx, nexty);
    }
    return;
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i < n; i++) {
        if (grid[i][0] == 1) dfs(grid, i, 0);
        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);
    }
    // 从上边和下边 向中间遍历
    for (int j = 0; j < m; j++) {
        if (grid[0][j] == 1) dfs(grid, 0, j);
        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);
    }
    count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) dfs(grid, i, j);
        }
    }
    cout << count << endl;
}
```

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
int count = 0;
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void bfs(vector<vector<int>>& grid, int x, int y) {
    queue<pair<int, int>> que;
    que.push({x, y});
    grid[x][y] = 0; // 只要加入队列，立刻标记
    count++;
    while(!que.empty()) {
        pair<int ,int> cur = que.front(); que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for (int i = 0; i < 4; i++) {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            if (grid[nextx][nexty] == 1) {
                que.push({nextx, nexty});
                count++;
                grid[nextx][nexty] = 0; // 只要加入队列立刻标记
            }
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i < n; i++) {
        if (grid[i][0] == 1) bfs(grid, i, 0);
        if (grid[i][m - 1] == 1) bfs(grid, i, m - 1);
    }
    // 从上边和下边 向中间遍历
    for (int j = 0; j < m; j++) {
        if (grid[0][j] == 1) bfs(grid, 0, j);
        if (grid[n - 1][j] == 1) bfs(grid, n - 1, j);
    }
    count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) bfs(grid, i, j);
        }
    }

    cout << count << endl;
}
```

###  沉没孤岛 

https://kamacoder.com/problempage.php?pid=1174

![沉没孤岛](../../../.vuepress/public/img\沉没孤岛.jpg)

```c++
#include <iostream>
#include <vector>
using namespace std;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向
void dfs(vector<vector<int>>& grid, int x, int y) {
    grid[x][y] = 2;
    for (int i = 0; i < 4; i++) { // 向四个方向遍历
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
        // 不符合条件，不继续遍历
        if (grid[nextx][nexty] == 0 || grid[nextx][nexty] == 2) continue;
        dfs (grid, nextx, nexty);
    }
    return;
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    // 步骤一：
    // 从左侧边，和右侧边 向中间遍历
    for (int i = 0; i < n; i++) {
        if (grid[i][0] == 1) dfs(grid, i, 0);
        if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);
    }

    // 从上边和下边 向中间遍历
    for (int j = 0; j < m; j++) {
        if (grid[0][j] == 1) dfs(grid, 0, j);
        if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);
    }
    // 步骤二、步骤三
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) grid[i][j] = 0;
            if (grid[i][j] == 2) grid[i][j] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << grid[i][j] << " ";
        }
        cout << endl;
    }
}
```

### 水流问题

https://kamacoder.com/problempage.php?pid=1175

![水流问题](../../../.vuepress/public/img\水流问题.jpg)

超时：遍历每个点，然后看这个点 能不能同时到达第一组边界和第二组边界

```c++
#include <iostream>
#include <vector>
using namespace std;
int n, m;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};

// 从 x，y 出发 把可以走的地方都标记上
void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    if (visited[x][y]) return;

    visited[x][y] = true;

    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;
        if (grid[x][y] < grid[nextx][nexty]) continue; // 高度不合适

        dfs (grid, visited, nextx, nexty);
    }
    return;
}
bool isResult(vector<vector<int>>& grid, int x, int y) {
    vector<vector<bool>> visited(n, vector<bool>(m, false));

    // 深搜，将x,y出发 能到的节点都标记上。
    dfs(grid, visited, x, y);
    bool isFirst = false;
    bool isSecond = false;

    // 以下就是判断x，y出发，是否到达第一组边界和第二组边界
    // 第一边界的上边
    for (int j = 0; j < m; j++) {
        if (visited[0][j]) {
            isFirst = true;
            break;
        }
    }
    // 第一边界的左边
    for (int i = 0; i < n; i++) {
        if (visited[i][0]) {
            isFirst = true;
            break;
        }
    }
    // 第二边界右边
    for (int j = 0; j < m; j++) {
        if (visited[n - 1][j]) {
            isSecond = true;
            break;
        }
    }
    // 第二边界下边
    for (int i = 0; i < n; i++) {
        if (visited[i][m - 1]) {
            isSecond = true;
            break;
        }
    }
    if (isFirst && isSecond) return true;
    return false;
}


int main() {
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    // 遍历每一个点，看是否能同时到达第一组边界和第二组边界
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (isResult(grid, i, j)) {
                cout << i << " " << j << endl;
            }
        }
    }
}

```

从第一组边界上的节点 逆流而上，将遍历过的节点都标记上。

同样从第二组边界的边上节点 逆流而上，将遍历过的节点也标记上。

然后**两方都标记过的节点就是既可以流太平洋也可以流大西洋的节点**

![水流问题1](../../../.vuepress/public/img\水流问题1.jpg)

![水流问题1](../../../.vuepress/public/img\水流问题2.jpg)

```c++
#include <iostream>
#include <vector>
using namespace std;
int n, m;
int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1};
void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    if (visited[x][y]) return;

    visited[x][y] = true;

    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;
        if (grid[x][y] > grid[nextx][nexty]) continue; // 注意：这里是从低向高遍历

        dfs (grid, visited, nextx, nexty);
    }
    return;
}



int main() {

    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    // 标记从第一组边界上的节点出发，可以遍历的节点
    vector<vector<bool>> firstBorder(n, vector<bool>(m, false));

    // 标记从第二组边界上的节点出发，可以遍历的节点
    vector<vector<bool>> secondBorder(n, vector<bool>(m, false));

    // 从最上和最下行的节点出发，向高处遍历
    for (int i = 0; i < n; i++) {
        dfs (grid, firstBorder, i, 0); // 遍历最左列，接触第一组边界
        dfs (grid, secondBorder, i, m - 1); // 遍历最右列，接触第二组边界
    }

    // 从最左和最右列的节点出发，向高处遍历
    for (int j = 0; j < m; j++) {
        dfs (grid, firstBorder, 0, j); // 遍历最上行，接触第一组边界
        dfs (grid, secondBorder, n - 1, j); // 遍历最下行，接触第二组边界
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            // 如果这个节点，从第一组边界和第二组边界出发都遍历过，就是结果
            if (firstBorder[i][j] && secondBorder[i][j]) cout << i << " " << j << endl;
        }
    }


}
```

### 建造最大岛屿

https://kamacoder.com/problempage.php?pid=1176

![建造最大人工岛](../../../.vuepress/public/img\建造最大人工岛.jpg)

![建造最大人工岛1](../../../.vuepress/public/img\建造人工岛1.jpg)

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>
using namespace std;
int n, m;
int count;

int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {
    if (visited[x][y] || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    visited[x][y] = true; // 标记访问过
    grid[x][y] = mark; // 给陆地标记新标签
    count++;
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= n || nexty < 0 || nexty >= m) continue;  // 越界了，直接跳过
        dfs(grid, visited, nextx, nexty, mark);
    }
}

int main() {
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点
    unordered_map<int ,int> gridNum;
    int mark = 2; // 记录每个岛屿的编号
    bool isAllGrid = true; // 标记是否整个地图都是陆地
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 0) isAllGrid = false;
            if (!visited[i][j] && grid[i][j] == 1) {
                count = 0;
                dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true
                gridNum[mark] = count; // 记录每一个岛屿的面积
                mark++; // 记录下一个岛屿编号
            }
        }
    }
    if (isAllGrid) {
        cout << n * m << endl; // 如果都是陆地，返回全面积
        return 0; // 结束程序
    }

    // 以下逻辑是根据添加陆地的位置，计算周边岛屿面积之和
    int result = 0; // 记录最后结果
    unordered_set<int> visitedGrid; // 标记访问过的岛屿
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            count = 1; // 记录连接之后的岛屿数量
            visitedGrid.clear(); // 每次使用时，清空
            if (grid[i][j] == 0) {
                for (int k = 0; k < 4; k++) {
                    int neari = i + dir[k][1]; // 计算相邻坐标
                    int nearj = j + dir[k][0];
                    if (neari < 0 || neari >= n || nearj < 0 || nearj >= m) continue;
                    if (visitedGrid.count(grid[neari][nearj])) continue; // 添加过的岛屿不要重复添加
                    // 把相邻四面的岛屿数量加起来
                    count += gridNum[grid[neari][nearj]];
                    visitedGrid.insert(grid[neari][nearj]); // 标记该岛屿已经添加过
                }
            }
            result = max(result, count);
        }
    }
    cout << result << endl;

}
```

### 字符串接龙 

https://kamacoder.com/problempage.php?pid=1183

![字符串接龙](../../../.vuepress/public/img\字符串接龙.jpg)

```c++
#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <queue>
using namespace std;
int main() {
    string beginStr, endStr, str;
    int n;
    cin >> n;
    unordered_set<string> strSet;
    cin >> beginStr >> endStr;
    for (int i = 0; i < n; i++) {
        cin >> str;
        strSet.insert(str);
    }

    // 记录strSet里的字符串是否被访问过，同时记录路径长度
    unordered_map<string, int> visitMap; // <记录的字符串，路径长度>

    // 初始化队列
    queue<string> que;
    que.push(beginStr);

    // 初始化visitMap
    visitMap.insert(pair<string, int>(beginStr, 1));

    while(!que.empty()) {
        string word = que.front();
        que.pop();
        int path = visitMap[word]; // 这个字符串在路径中的长度

        // 开始在这个str中，挨个字符去替换
        for (int i = 0; i < word.size(); i++) {
            string newWord = word; // 用一个新字符串替换str，因为每次要置换一个字符

            // 遍历26的字母
            for (int j = 0 ; j < 26; j++) {
                newWord[i] = j + 'a';
                if (newWord == endStr) { // 发现替换字母后，字符串与终点字符串相同
                    cout <<  path + 1 << endl; // 找到了路径 
                    return 0;
                }
                // 字符串集合里出现了newWord，并且newWord没有被访问过
                if (strSet.find(newWord) != strSet.end()
                        && visitMap.find(newWord) == visitMap.end()) {
                    // 添加访问信息，并将新字符串放到队列中
                    visitMap.insert(pair<string, int>(newWord, path + 1));
                    que.push(newWord);
                }
            }
        }
    }

    // 没找到输出0
    cout << 0 << endl;

}
```

### 有向图的完全可达性

https://kamacoder.com/problempage.php?pid=1177

```c++
// 写法一：dfs 处理当前访问的节点
#include <iostream>
#include <vector>
#include <list>
using namespace std;

void dfs(const vector<list<int>>& graph, int key, vector<bool>& visited) {
    if (visited[key]) {
        return;
    }
    visited[key] = true;
    list<int> keys = graph[key];
    for (int key : keys) {
        // 深度优先搜索遍历
        dfs(graph, key, visited);
    }
}

int main() {
    int n, m, s, t;
    cin >> n >> m;

    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<list<int>> graph(n + 1); // 邻接表
    while (m--) {
        cin >> s >> t;
        // 使用邻接表 ，表示 s -> t 是相连的
        graph[s].push_back(t);
    }
    vector<bool> visited(n + 1, false);
    dfs(graph, 1, visited);
    //检查是否都访问到了
    for (int i = 1; i <= n; i++) {
        if (visited[i] == false) {
            cout << -1 << endl;
            return 0;
        }
    }
    cout << 1 << endl;
}
```

```c++
#include <iostream>
#include <vector>
#include <list>
#include <queue>
using namespace std;

int main() {
    int n, m, s, t;
    cin >> n >> m;

    vector<list<int>> graph(n + 1);
    while (m--) {
        cin >> s >> t;
        graph[s].push_back(t);

    }
    vector<bool> visited(n + 1, false);
    visited[1] = true; //  1 号房间开始
    queue<int> que;
    que.push(1); //  1 号房间开始

    // 广度优先搜索的过程
    while (!que.empty()) {
        int key = que.front(); que.pop();
         list<int> keys = graph[key];
         for (int key : keys) {
             if (!visited[key]) {
                 que.push(key);
                 visited[key] = true;
             }
         }
    }

    for (int i = 1; i <= n; i++) {
        if (visited[i] == false) {
            cout << -1 << endl;
            return 0;
        }
    }
    cout << 1 << endl;
}
```

### 岛屿的周长 

https://kamacoder.com/problempage.php?pid=1178

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    int direction[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                for (int k = 0; k < 4; k++) {       // 上下左右四个方向
                    int x = i + direction[k][0];
                    int y = j + direction[k][1];    // 计算周边坐标x,y
                    if (x < 0                       // x在边界上
                            || x >= grid.size()     // x在边界上
                            || y < 0                // y在边界上
                            || y >= grid[0].size()  // y在边界上
                            || grid[x][y] == 0) {   // x,y位置是水域
                        result++;
                    }
                }
            }
        }
    }
    cout << result << endl;

}
```

result = 岛屿数量 * 4 - cover * 2;

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
    int sum = 0;    // 陆地数量
    int cover = 0;  // 相邻数量
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] == 1) {
                sum++; // 统计总的陆地数量
                // 统计上边相邻陆地
                if(i - 1 >= 0 && grid[i - 1][j] == 1) cover++;
                // 统计左边相邻陆地
                if(j - 1 >= 0 && grid[i][j - 1] == 1) cover++;
                // 为什么没统计下边和右边？ 因为避免重复计算
            }
        }
    }

    cout << sum * 4 - cover * 2 << endl;
}
```

###   [并查集模板](https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9)

```c++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}


// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

```java
public class union {
    int n;
    int[] father = new int[1000 + 1];

    public void init(int n) {
        this.n = n;
        for (int i = 0; i < father.length; i++) {
            father[i] = i;
        }
    }

    public int find(int u) {
        if (u == father[u]) {
            return u;
        }
        return father[u] = find(father[u]);
    }

    public boolean isSame(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }

    // 根进行连接 即不能用isSame简写,此时得到的不是u的根而是u本身
    public void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) {
            return;
        }
        father[v] = u;
    }
}
```



### 寻找存在的路径 

https://kamacoder.com/problempage.php?pid=1179

```c++
#include <iostream>
#include <vector>
using namespace std;

int n; // 节点数量
vector<int> father = vector<int> (101, 0); // 按照节点大小定义数组大小

// 并查集初始化
void init() {
    for (int i = 1; i <= n; i++)  father[i] = i;
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}

int main() {
    int m, s, t, source, destination;
    cin >> n >> m;
    init();
    while (m--) {
        cin >> s >> t;
        join(s, t);
    }
    cin >> source >> destination;
    if (isSame(source, destination)) cout << 1 << endl;
    else cout << 0 << endl;
}
```

### 冗余连接

https://kamacoder.com/problempage.php?pid=1181

```
#include <iostream>
#include <vector>
using namespace std;
int n; // 节点数量
vector<int> father(1001, 0); // 按照节点大小范围定义数组

// 并查集初始化
void init() {
    for (int i = 0; i <= n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}

int main() {
    int s, t;
    cin >> n;
    init();
    for (int i = 0; i < n; i++) {
        cin >> s >> t;
        if (isSame(s, t)) {
            cout << s << " " << t << endl;
            return 0;
        } else {
            join(s, t);
        }
    }
}
```

### 冗余连接 II

https://kamacoder.com/problempage.php?pid=1182

[讲解](https://programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF)：

![冗余连接](../../../.vuepress/public/img\冗余连接.jpg)

![冗余连接](../../../.vuepress/public/img\冗余连接1.jpg)

![冗余连接](../../../.vuepress/public/img\冗余连接2.jpg)

综上，如果发现入度为2的节点，我们需要判断 删除哪一条边，删除后本图能成为有向树。如果是删哪个都可以，优先删顺序靠后的边。

如果没有发现入度为2的节点，则要删除环中的边

```c++
#include <iostream>
#include <vector>
using namespace std;
int n;
vector<int> father (1001, 0);
// 并查集初始化
void init() {
    for (int i = 1; i <= n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}
// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u);
    v = find(v);
    if (u == v) return ;
    father[v] = u;
}
// 判断 u 和 v是否找到同一个根
bool same(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 在有向图里找到删除的那条边，使其变成树
void getRemoveEdge(const vector<vector<int>>& edges) {
    init(); // 初始化并查集
    for (int i = 0; i < n; i++) { // 遍历所有的边
        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边
            cout << edges[i][0] << " " << edges[i][1];
            return;
        } else {
            join(edges[i][0], edges[i][1]);
        }
    }
}

// 删一条边之后判断是不是树
bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
    init(); // 初始化并查集
    for (int i = 0; i < n; i++) {
        if (i == deleteEdge) continue;
        if (same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树
            return false;
        }
        join(edges[i][0], edges[i][1]);
    }
    return true;
}

int main() {
    int s, t;
    vector<vector<int>> edges;
    cin >> n;
    vector<int> inDegree(n + 1, 0); // 记录节点入度
    for (int i = 0; i < n; i++) {
        cin >> s >> t;
        inDegree[t]++;
        edges.push_back({s, t});
    }

    vector<int> vec; // 记录入度为2的边（如果有的话就两条边）
    // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边
    for (int i = n - 1; i >= 0; i--) {
        if (inDegree[edges[i][1]] == 2) {
            vec.push_back(i);
        }
    }
    if (vec.size() > 0) {
        // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边
        if (isTreeAfterRemoveEdge(edges, vec[0])) {
            cout << edges[vec[0]][0] << " " << edges[vec[0]][1];
        } else {
            cout << edges[vec[1]][0] << " " << edges[vec[1]][1];
        }
        return 0;
    }

    // 处理情况三
    // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了
    getRemoveEdge(edges);
}
```

### prim

```c++
#include<iostream>
#include<vector>
#include <climits>

using namespace std;
int main() {
    int v, e;
    int x, y, k;
    cin >> v >> e;
    // 填一个默认最大值，题目描述val最大为10000
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    while (e--) {
        cin >> x >> y >> k;
        // 因为是双向图，所以两个方向都要填上
        grid[x][y] = k;
        grid[y][x] = k;

    }
    // 所有节点到最小生成树的最小距离
    vector<int> minDist(v + 1, 10001);

    // 这个节点是否在树里
    vector<bool> isInTree(v + 1, false);

    // 我们只需要循环 n-1次，建立 n - 1条边，就可以把n个节点的图连在一起
    for (int i = 1; i < v; i++) {

        // 1、prim三部曲，第一步：选距离生成树最近节点
        int cur = -1; // 选中哪个节点 加入最小生成树
        int minVal = INT_MAX;
        for (int j = 1; j <= v; j++) { // 1 - v，顶点编号，这里下标从1开始
            //  选取最小生成树节点的条件：
            //  （1）不在最小生成树里
            //  （2）距离最小生成树最近的节点
            if (!isInTree[j] &&  minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }
        // 2、prim三部曲，第二步：最近节点（cur）加入生成树
        isInTree[cur] = true;

        // 3、prim三部曲，第三步：更新非生成树节点到生成树的距离（即更新minDist数组）
        // cur节点加入之后， 最小生成树加入了新的节点，那么所有节点到 最小生成树的距离（即minDist数组）需要更新一下
        // 由于cur节点是新加入到最小生成树，那么只需要关心与 cur 相连的 非生成树节点 的距离 是否比 原来 非生成树节点到生成树节点的距离更小了呢
        for (int j = 1; j <= v; j++) {
            // 更新的条件：
            // （1）节点是 非生成树里的节点
            // （2）与cur相连的某节点的权值 比 该某节点距离最小生成树的距离小
            // 很多录友看到自己 就想不明白什么意思，其实就是 cur 是新加入 最小生成树的节点，那么 所有非生成树的节点距离生成树节点的最近距离 由于 cur的新加入，需要更新一下数据了
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];
            }
        }
    }
    // 统计结果
    int result = 0;
    for (int i = 2; i <= v; i++) { // 不计第一个顶点，因为统计的是边的权值，v个节点有 v-1条边
        result += minDist[i];
    }
    cout << result << endl;

}
```
![prim](../../../.vuepress/public/img\prim.jpg)

```c++
#include<iostream>
#include<vector>
#include <climits>

using namespace std;
int main() {
    int v, e;
    int x, y, k;
    cin >> v >> e;
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    while (e--) {
        cin >> x >> y >> k;
        grid[x][y] = k;
        grid[y][x] = k;
    }

    vector<int> minDist(v + 1, 10001);
    vector<bool> isInTree(v + 1, false);

    //加上初始化
    vector<int> parent(v + 1, -1);

    for (int i = 1; i < v; i++) {
        int cur = -1;
        int minVal = INT_MAX;
        for (int j = 1; j <= v; j++) {
            if (!isInTree[j] &&  minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }

        isInTree[cur] = true;
        for (int j = 1; j <= v; j++) {
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];

                parent[j] = cur; // 记录边
            }
        }
    }
    // 输出 最小生成树边的链接情况
    for (int i = 1; i <= v; i++) {
        cout << i << "->" << parent[i] << endl;
    }
}
```

###  kruskal

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// l,r为 边两边的节点，val为边的数值
struct Edge {
    int l, r, val;
};

// 节点数量
int n = 10001;
// 并查集标记节点关系的数组
vector<int> father(n, -1); // 节点编号是从1开始的，n要大一些

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}

// 并查集的查找操作
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 并查集的加入集合
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}

int main() {

    int v, e;
    int v1, v2, val;
    vector<Edge> edges;
    int result_val = 0;
    cin >> v >> e;
    while (e--) {
        cin >> v1 >> v2 >> val;
        edges.push_back({v1, v2, val});
    }

    // 执行Kruskal算法
    // 按边的权值对边进行从小到大排序
    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.val < b.val;
    });

    // 并查集初始化
    init();

    // 从头开始遍历边
    for (Edge edge : edges) {
        // 并查集，搜出两个节点的祖先
        int x = find(edge.l);
        int y = find(edge.r);

        // 如果祖先不同，则不在同一个集合
        if (x != y) {
            result_val += edge.val; // 这条边可以作为生成树的边
            join(x, y); // 两个节点加入到同一个集合
        }
    }
    cout << result_val << endl;
    return 0;
}
```

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Edge {
    int l, r, val;
};


int n = 10001;

vector<int> father(n, -1); 

void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}

int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); 
}

void join(int u, int v) {
    u = find(u); 
    v = find(v); 
    if (u == v) return ; 
    father[v] = u;
}

int main() {

    int v, e;
    int v1, v2, val;
    vector<Edge> edges;
    int result_val = 0;
    cin >> v >> e;
    while (e--) {
        cin >> v1 >> v2 >> val;
        edges.push_back({v1, v2, val});
    }

    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.val < b.val;
    });

    vector<Edge> result; // 存储最小生成树的边

    init();

    for (Edge edge : edges) {

        int x = find(edge.l);
        int y = find(edge.r);


        if (x != y) {
            result.push_back(edge); // 保存最小生成树的边
            result_val += edge.val; 
            join(x, y);
        }
    }

    // 打印最小生成树的边
    for (Edge edge : result) {
        cout << edge.l << " - " << edge.r << " : " << edge.val << endl;
    }

    return 0;
}
```

### 拓扑排序

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;
int main() {
    int m, n, s, t;
    cin >> n >> m;
    vector<int> inDegree(n, 0); // 记录每个文件的入度

    unordered_map<int, vector<int>> umap;// 记录文件依赖关系
    vector<int> result; // 记录结果

    while (m--) {
        // s->t，先有s才能有t
        cin >> s >> t;
        inDegree[t]++; // t的入度加一
        umap[s].push_back(t); // 记录s指向哪些文件
    }
    queue<int> que;
    for (int i = 0; i < n; i++) {
        // 入度为0的文件，可以作为开头，先加入队列
        if (inDegree[i] == 0) que.push(i);
        //cout << inDegree[i] << endl;
    }
    // int count = 0;
    while (que.size()) {
        int  cur = que.front(); // 当前选中的文件
        que.pop();
        //count++;
        result.push_back(cur);
        vector<int> files = umap[cur]; //获取该文件指向的文件
        if (files.size()) { // cur有后续文件
            for (int i = 0; i < files.size(); i++) {
                inDegree[files[i]] --; // cur的指向的文件入度-1
                if(inDegree[files[i]] == 0) que.push(files[i]);
            }
        }
    }
    if (result.size() == n) {
        for (int i = 0; i < n - 1; i++) cout << result[i] << " ";
        cout << result[n - 1];
    } else cout << -1 << endl;
}
```

### dijkstra 

- 第一步，选源点到哪个节点近且该节点未被访问过
- 第二步，该最近节点被标记访问过
- 第三步，更新非访问节点到源点的距离（即更新minDist数组）

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        int[][] grid = new int[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(grid[i], Integer.MAX_VALUE);
        }

        for (int i = 0; i < m; i++) {
            int p1 = scanner.nextInt();
            int p2 = scanner.nextInt();
            int val = scanner.nextInt();
            grid[p1][p2] = val;
        }

        int start = 1;
        int end = n;

        // 存储从源点到每个节点的最短距离
        int[] minDist = new int[n + 1];
        Arrays.fill(minDist, Integer.MAX_VALUE);

        // 记录顶点是否被访问过
        boolean[] visited = new boolean[n + 1];

        minDist[start] = 0;  // 起始点到自身的距离为0

        for (int i = 1; i <= n; i++) { // 遍历所有节点

            int minVal = Integer.MAX_VALUE;
            int cur = 1;

            // 1、选距离源点最近且未访问过的节点
            for (int v = 1; v <= n; ++v) {
                if (!visited[v] && minDist[v] < minVal) {
                    minVal = minDist[v];
                    cur = v;
                }
            }

            visited[cur] = true;  // 2、标记该节点已被访问

            // 3、第三步，更新非访问节点到源点的距离（即更新minDist数组）
            for (int v = 1; v <= n; v++) {
                if (!visited[v] && grid[cur][v] != Integer.MAX_VALUE && minDist[cur] + grid[cur][v] < minDist[v]) {
                    minDist[v] = minDist[cur] + grid[cur][v];
                }
            }
        }

        if (minDist[end] == Integer.MAX_VALUE) {
            System.out.println(-1); // 不能到达终点
        } else {
            System.out.println(minDist[end]); // 到达终点最短路径
        }
    }
}
```

### dijkstra（堆优化版）

```java
import java.util.*;

class Edge {
    int to;  // 邻接顶点
    int val; // 边的权重

    Edge(int to, int val) {
        this.to = to;
        this.val = val;
    }
}

class MyComparison implements Comparator<Pair<Integer, Integer>> {
    @Override
    public int compare(Pair<Integer, Integer> lhs, Pair<Integer, Integer> rhs) {
        return Integer.compare(lhs.second, rhs.second);
    }
}

class Pair<U, V> {
    public final U first;
    public final V second;

    public Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();

        List<List<Edge>> grid = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            grid.add(new ArrayList<>());
        }

        for (int i = 0; i < m; i++) {
            int p1 = scanner.nextInt();
            int p2 = scanner.nextInt();
            int val = scanner.nextInt();
            grid.get(p1).add(new Edge(p2, val));
        }

        int start = 1;  // 起点
        int end = n;    // 终点

        // 存储从源点到每个节点的最短距离
        int[] minDist = new int[n + 1];
        Arrays.fill(minDist, Integer.MAX_VALUE);

        // 记录顶点是否被访问过
        boolean[] visited = new boolean[n + 1];

        // 优先队列中存放 Pair<节点，源点到该节点的权值>
        PriorityQueue<Pair<Integer, Integer>> pq = new PriorityQueue<>(new MyComparison());

        // 初始化队列，源点到源点的距离为0，所以初始为0
        pq.add(new Pair<>(start, 0));

        minDist[start] = 0;  // 起始点到自身的距离为0

        while (!pq.isEmpty()) {
            // 1. 第一步，选源点到哪个节点近且该节点未被访问过（通过优先级队列来实现）
            // <节点， 源点到该节点的距离>
            Pair<Integer, Integer> cur = pq.poll();

            if (visited[cur.first]) continue;

            // 2. 第二步，该最近节点被标记访问过
            visited[cur.first] = true;

            // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
            for (Edge edge : grid.get(cur.first)) { // 遍历 cur指向的节点，cur指向的节点为 edge
                // cur指向的节点edge.to，这条边的权值为 edge.val
                if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist
                    minDist[edge.to] = minDist[cur.first] + edge.val;
                    pq.add(new Pair<>(edge.to, minDist[edge.to]));
                }
            }
        }

        if (minDist[end] == Integer.MAX_VALUE) {
            System.out.println(-1); // 不能到达终点
        } else {
            System.out.println(minDist[end]); // 到达终点最短路径
        }
    }
}
```

### Bellman_ford

```c++
//https://programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I.html
#include <iostream>
#include <vector>
#include <list>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid;

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid.push_back({p1, p2, val});

    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;
    for (int i = 1; i < n; i++) { // 对所有边 松弛 n-1 次
        for (vector<int> &side : grid) { // 每一次松弛，都是对所有边进行松弛
            int from = side[0]; // 边的出发点
            int to = side[1]; // 边的到达点
            int price = side[2]; // 边的权值
            // 松弛操作 
            // minDist[from] != INT_MAX 防止从未计算过的节点出发
            if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) { 
                minDist[to] = minDist[from] + price;  
            }
        }
    }
    if (minDist[end] == INT_MAX) cout << "unconnected" << endl; // 不能到达终点
    else cout << minDist[end] << endl; // 到达终点最短路径
}
```

### Bellman_ford 队列优化算法（又名SPFA）

**只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了**

```c++
//https://programmercarl.com/kamacoder/0094.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93I-SPFA.html#%E8%83%8C%E6%99%AF
#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include <climits>
using namespace std;

struct Edge { //邻接表
    int to;  // 链接的节点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};


int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<list<Edge>> grid(n + 1); // 邻接表

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid[p1].push_back(Edge(p2, val));
    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;

    queue<int> que;
    que.push(start); // 队列里放入起点

    while (!que.empty()) {

        int node = que.front(); que.pop();

        for (Edge edge : grid[node]) {
            int from = node;
            int to = edge.to;
            int value = edge.val;
            if (minDist[to] > minDist[from] + value) { // 开始松弛
                minDist[to] = minDist[from] + value;
                que.push(to);
            }
        }

    }

    if (minDist[end] == INT_MAX) cout << "unconnected" << endl; // 不能到达终点
    else cout << minDist[end] << endl; // 到达终点最短路径
}
```

### bellman_ford之判断负权回路

```C++
//https://programmercarl.com/kamacoder/0095.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93II.html#%E6%80%9D%E8%B7%AF
#include <iostream>
#include <vector>
#include <list>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid;

    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid.push_back({p1, p2, val});

    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;
    bool flag = false;
    for (int i = 1; i <= n; i++) { // 这里我们松弛n次，最后一次判断负权回路
        for (vector<int> &side : grid) {
            int from = side[0];
            int to = side[1];
            int price = side[2];
            if (i < n) {
                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) minDist[to] = minDist[from] + price;
            } else { // 多加一次松弛判断负权回路
                if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + price) flag = true;

            }
        }

    }

    if (flag) cout << "circle" << endl;
    else if (minDist[end] == INT_MAX) {
        cout << "unconnected" << endl;
    } else {
        cout << minDist[end] << endl;
    }
}
```

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <list>
#include <climits>
using namespace std;

struct Edge { //邻接表
    int to;  // 链接的节点
    int val; // 边的权重

    Edge(int t, int w): to(t), val(w) {}  // 构造函数
};


int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<list<Edge>> grid(n + 1); // 邻接表

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid[p1].push_back(Edge(p2, val));
    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX);
    minDist[start] = 0;

    queue<int> que;
    que.push(start); // 队列里放入起点 
    
    vector<int> count(n+1, 0); // 记录节点加入队列几次
    count[start]++;

    bool flag = false;
    while (!que.empty()) {

        int node = que.front(); que.pop();

        for (Edge edge : grid[node]) {
            int from = node;
            int to = edge.to;
            int value = edge.val;
            if (minDist[to] > minDist[from] + value) { // 开始松弛
                minDist[to] = minDist[from] + value;
                que.push(to);
                count[to]++; 
                if (count[to] == n) {// 如果加入队列次数超过 n-1次 就说明该图与负权回路
                    flag = true;
                    while (!que.empty()) que.pop();
                    break;
                }
            }
        }
    }

    if (flag) cout << "circle" << endl;
    else if (minDist[end] == INT_MAX) {
        cout << "unconnected" << endl;
    } else {
        cout << minDist[end] << endl;
    }

}
```

### bellman_ford之单源有限最短路

```
https://programmercarl.com/kamacoder/0096.%E5%9F%8E%E5%B8%82%E9%97%B4%E8%B4%A7%E7%89%A9%E8%BF%90%E8%BE%93III.html#%E6%80%9D%E8%B7%AF
```

**最多经过 k 个城市的条件下，而不是一定经过k个城市，也可以经过的城市数量比k小，但要最短的路径**。



### Floyd算法

grid[i\][j\][k] = m，表示 节点i 到 节点j 以[1...k] 集合为中间节点的最短距离为m

```c++
//https://programmercarl.com/kamacoder/0097.%E5%B0%8F%E6%98%8E%E9%80%9B%E5%85%AC%E5%9B%AD.html#%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B
#include <iostream>
#include <vector>
#include <list>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<vector<int>>> grid(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, 10005)));  // 因为边的最大距离是10^4
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        grid[p1][p2][0] = val;
        grid[p2][p1][0] = val; // 注意这里是双向图

    }
    // 开始 floyd
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                grid[i][j][k] = min(grid[i][j][k-1], grid[i][k][k-1] + grid[k][j][k-1]);
            }
        }
    }
    // 输出结果
    int z, start, end;
    cin >> z;
    while (z--) {
        cin >> start >> end;
        if (grid[start][end][n] == 10005) cout << -1 << endl;
        else cout << grid[start][end][n] << endl;
    }
}
```

降维

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid(n + 1, vector<int>(n + 1, 10005));  // 因为边的最大距离是10^4

    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        grid[p1][p2] = val;
        grid[p2][p1] = val; // 注意这里是双向图

    }
    // 开始 floyd
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                grid[i][j] = min(grid[i][j], grid[i][k] + grid[k][j]);
            }
        }
    }
    // 输出结果
    int z, start, end;
    cin >> z;
    while (z--) {
        cin >> start >> end;
        if (grid[start][end] == 10005) cout << -1 << endl;
        else cout << grid[start][end] << endl;
    }
}
```



### A*算法

**A \* 算法并不能保证一定是最短路**

```c++
//https://programmercarl.com/kamacoder/0126.%E9%AA%91%E5%A3%AB%E7%9A%84%E6%94%BB%E5%87%BBastar.html#%E6%80%9D%E8%B7%AF
#include<iostream>
#include<queue>
#include<string.h>
using namespace std;
int moves[1001][1001];
int dir[8][2]={-2,-1,-2,1,-1,2,1,2,2,1,2,-1,1,-2,-1,-2};
int b1, b2;
// F = G + H
// G = 从起点到该节点路径消耗
// H = 该节点到终点的预估消耗

struct Knight{
    int x,y;
    int g,h,f;
    bool operator < (const Knight & k) const{  // 重载运算符， 从小到大排序
     return k.f < f;
    }
};

priority_queue<Knight> que;

int Heuristic(const Knight& k) { // 欧拉距离
    return (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2); // 统一不开根号，这样可以提高精度
}
void astar(const Knight& k)
{
    Knight cur, next;
	que.push(k);
	while(!que.empty())
	{
		cur=que.top(); que.pop();
		if(cur.x == b1 && cur.y == b2)
		break;
		for(int i = 0; i < 8; i++)
		{
			next.x = cur.x + dir[i][0];
			next.y = cur.y + dir[i][1];
			if(next.x < 1 || next.x > 1000 || next.y < 1 || next.y > 1000)
			continue;
			if(!moves[next.x][next.y])
			{
				moves[next.x][next.y] = moves[cur.x][cur.y] + 1;

                // 开始计算F
				next.g = cur.g + 5; // 统一不开根号，这样可以提高精度，马走日，1 * 1 + 2 * 2 = 5
                next.h = Heuristic(next);
                next.f = next.g + next.h;
                que.push(next);
			}
		}
	}
}

int main()
{
    int n, a1, a2;
    cin >> n;
    while (n--) {
        cin >> a1 >> a2 >> b1 >> b2;
        memset(moves,0,sizeof(moves));
        Knight start;
        start.x = a1;
        start.y = a2;
        start.g = 0;
        start.h = Heuristic(start);
        start.f = start.g + start.h;
		astar(start);
        while(!que.empty()) que.pop(); // 队列清空
		cout << moves[b1][b2] << endl;
	}
	return 0;
}
```

![最短路问题](../../../.vuepress/public/img\最短路问题.jpg)

## 额外题目

### 有多少小于当前数字的数字 1365

https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    int[] res = new int[nums.length];
    int[] sortNums = Arrays.copyOf(nums, nums.length);
    Arrays.sort(sortNums);
    Map<Integer, Integer> map = new HashMap<>();
    map.put(sortNums[0], 0);
    for (int i = 1; i < sortNums.length; i++) {
        if (sortNums[i] > sortNums[i - 1]) {
            map.put(sortNums[i], i);
        }
    }
    for (int i = 0; i < nums.length; i++) {
        res[i] = map.get(nums[i]);
    }
    return res;
}
```

### 有效的山脉数组 941

https://leetcode.cn/problems/valid-mountain-array/description/

```java
public boolean validMountainArray(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            left = i;
        } else {
            break;
        }
    }
    for (int i = arr.length - 1; i >= 1; i--) {
        if (arr[i - 1] > arr[i]) {
            right = i - 1;
        } else {
            break;
        }
    }
    if (left != 0 && right != arr.length - 1 && left == right) {
        return true;
    }
    return false;
}
```

### 独一无二的出现次数 1207

https://leetcode.cn/problems/unique-number-of-occurrences/description/

```java
public boolean uniqueOccurrences(int[] arr) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < arr.length; i++) {
        map.put(arr[i], map.getOrDefault(arr[i], 0) + 1);
    }
    Set<Integer> set = new HashSet<>();
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        if (set.contains(entry.getValue())) {
            return false;
        }
        set.add(entry.getValue());
    }
    return true;
}
```

### 移动零 283

https://leetcode.cn/problems/move-zeroes

```java
public void moveZeroes(int[] nums) {
    int left = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != 0) {
            int temp = nums[i];
            nums[i] = nums[left];
            nums[left] = temp;
            left++;
        }
    }
}
```

### 旋转数组 189

https://leetcode.cn/problems/rotate-array/

```java
private void reverse(int[] nums, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        int temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;
    }
}
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k %= n;
    reverse(nums, 0, n - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, n - 1);
}
```

### 寻找数组的中心下标 724

https://leetcode.cn/problems/find-pivot-index/description/

```java
public int pivotIndex(int[] nums) {
    int sum = Arrays.stream(nums).sum();
    int leftSum = 0;
    for (int i = 0; i < nums.length; i++) {
        int rightSum = sum - leftSum - nums[i];
        if (leftSum == rightSum) {
            return i;
        }
        leftSum += nums[i];
    }
    return -1;
}
```

### 在排序数组中查找元素的第一个和最后一个位置

https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/

```java
public int[] searchRange(int[] nums, int target) {
    if (nums.length == 0) {
        return new int[]{-1, -1};
    }
    int leftIndex = searchIndex(nums, target);
    if (leftIndex >= nums.length || nums[leftIndex] != target) {
        return new int[]{-1, -1};
    }
    int rightIndex = searchIndex(nums, target + 1);
    return new int[]{leftIndex, rightIndex - 1};
}

// 大于等于target的最小位置
// 循环不变量：
// nums[left-1] < target
// nums[right] >= target
private int searchIndex(int[] nums, int target) {
    int left = 0;
    int right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (target > nums[mid]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

### 按奇偶排序数组II 922

https://leetcode.cn/problems/sort-array-by-parity-ii/

```java
public int[] sortArrayByParityII(int[] nums) {
    int even = 0;
    int odd = 1;
    while (even < nums.length && odd < nums.length) {
        while (even < nums.length && nums[even] % 2 == 0) {
            even += 2;
        }
        while (odd < nums.length && nums[odd] % 2 != 0) {
            odd += 2;
        }
        if (odd < nums.length && even < nums.length) {
            int temp = nums[odd];
            nums[odd] = nums[even];
            nums[even] = temp;
            odd += 2;
            even += 2;
        }
    }
    return nums;
}
```

### 搜索插入位置 35

https://leetcode.cn/problems/search-insert-position/description/

```java
public int searchInsert(int[] nums, int target) {
    return searchIndex(nums, target);
}

// 大于等于target的最小位置 小于所有的返回0 大于所有的返回nums.length
// 循环不变量：
// nums[left-1] < target
// nums[right] >= target
private int searchIndex(int[] nums, int target) {
    int left = 0;
    int right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (target > nums[mid]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

### 两两交换链表中的节点 24

https://leetcode.cn/problems/swap-nodes-in-pairs/

```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode cur = head.next;
    ListNode next = cur.next;
    cur.next = head;
    head.next = swapPairs(next);
    return cur;
}
```

```java
public ListNode swapPairs(ListNode head) {
    ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点
    dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
    ListNode cur = dumyhead;
    ListNode temp; // 临时节点，保存两个节点后面的节点
    ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点
    ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点
    while (cur.next != null && cur.next.next != null) {
        temp = cur.next.next.next;
        firstnode = cur.next;
        secondnode = cur.next.next;
        cur.next = secondnode;       // 步骤一
        secondnode.next = firstnode; // 步骤二
        firstnode.next = temp;      // 步骤三
        cur = firstnode; // cur移动，准备下一轮交换
    }
    return dumyhead.next;  
}
```

### 回文链表

https://leetcode.cn/problems/palindrome-linked-list/

```java
public boolean isPalindrome(ListNode head) {
    int len = 0;
    // 统计链表长度
    ListNode cur = head;
    while (cur != null) {
        len++;
        cur = cur.next;
    }
    cur = head;
    int[] res = new int[len];
    // 将元素加到数组之中
    for (int i = 0; i < res.length; i++){
        res[i] = cur.val;
        cur = cur.next;
    }
    // 比较回文
    for (int i = 0, j = len - 1; i < j; i++, j--){
        if (res[i] != res[j]){
            return false;
        }
    }
    return true;
}
```

### 重排链表 143

https://leetcode.cn/problems/reorder-list/description/

```java
public void reorderList(ListNode head) {
    reorderNode(head);
}

private ListNode reorderNode(ListNode head) {
    if (head == null || head.next == null || head.next.next == null) {
        return head;
    }
    ListNode next = head.next;
    // temp 倒数第二个结点
    ListNode temp = head;
    while (temp.next.next != null) {
        temp = temp.next;
    }
    head.next = temp.next;
    temp.next = null;
    head.next.next = reorderNode(next);
    return head;
}
```

### 环形链表 141

https://leetcode.cn/problems/linked-list-cycle/submissions/

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (fast != null && fast.next != null) {
        if (slow == fast) {
            return true;
        }
        slow = slow.next;
        fast = fast.next;
        fast = fast.next;
    }
    return false;
}
```

### 同构字符串 205 

https://leetcode.cn/problems/isomorphic-strings/

```java
public boolean isIsomorphic(String s, String t) {
    Map<Character, Character> map1 = new HashMap<>();
    Map<Character, Character> map2 = new HashMap<>();
    for (int i = 0, j = 0; i < s.length(); i++, j++) {
        if (!map1.containsKey(s.charAt(i))) {
            map1.put(s.charAt(i), t.charAt(j)); // map1保存 s[i] 到 t[j]的映射
        }
        if (!map2.containsKey(t.charAt(j))) {
            map2.put(t.charAt(j), s.charAt(i)); // map2保存 t[j] 到 s[i]的映射
        }
        // 无法映射，返回 false
        if (map1.get(s.charAt(i)) != t.charAt(j) || map2.get(t.charAt(j)) != s.charAt(i)) {
            return false;
        }
    }
    return true;
}
```

### 查找常用字符 1002

https://leetcode.cn/problems/find-common-characters/

```java

public List<String> commonChars(String[] A) {
    List<String> list = new ArrayList<>();
    int[] res = new int[26];
    for (char c : A[0].toCharArray()) {
        res[c - 'a']++;
    }
    for (int i = 1; i < A.length; i++) {
        int[] temp = new int[26];
        for (char c : A[i].toCharArray()) {
            temp[c - 'a']++;
        }
        for (int j = 0; j < 26; j++) {
            res[j] = Math.min(res[j], temp[j]);
        }
    }
    for (int i = 0; i < res.length; i++) {
        if (res[i] > 0) {
            for (int j = 0; j < res[i]; j++) {
                list.add(((char) ('a' + i) + ""));
            }
        }
    }
    return list;
}
```

### 长按键入 925

https://leetcode.cn/problems/long-pressed-name/

```java
public boolean isLongPressedName(String name, String typed) {
    int left = 0;
    int pressLeft = 0;
    while (left < name.length() && pressLeft < typed.length()) {
        if (typed.charAt(pressLeft) == name.charAt(left)) {
            pressLeft++;
            left++;
        } else if (pressLeft > 0 && typed.charAt(pressLeft) == typed.charAt(pressLeft - 1)) {
            pressLeft++;
        } else {
            return false;
        }
    }
    for (int i = pressLeft; i < typed.length(); i++) {
        if (i > 0 && typed.charAt(i) != typed.charAt(i - 1)) {
            return false;
        }
    }
    return left == name.length();
}
```

### 比较含退格的字符串 844

https://leetcode.cn/problems/backspace-string-compare/

```java
public boolean backspaceCompare(String s, String t) {
    return getBackspace(s).equals(getBackspace(t));
}

private String getBackspace(String s) {
    Stack<Character> stack = new Stack<>();
    int index = 0;
    while (index < s.length()) {
        if (s.charAt(index) == '#') {
            if (!stack.isEmpty()) {
                stack.pop();
            }
            index++;
        } else {
            stack.push(s.charAt(index++));
        }
    }
    StringBuilder stringBuilder = new StringBuilder();
    while (!stack.isEmpty()) {
        stringBuilder.append(stack.pop());
    }
    return stringBuilder.reverse().toString();
}
```

### 求根节点到叶节点数字之和 129

https://leetcode.cn/problems/sum-root-to-leaf-numbers/

```java
int sum = 0;

public int sumNumbers(TreeNode root) {
    dfs(root, "");
    return sum;
}

private void dfs(TreeNode root, String pre) {
    if (root.left == null && root.right == null) {
        sum += Integer.parseInt(pre + root.val);
        return;
    }
    if (root.left != null) {
        dfs(root.left, pre + root.val);
    }
    if (root.right != null) {
        dfs(root.right, pre + root.val);

    }
}
```

### 将二叉搜索树变平衡 1382

https://leetcode.cn/problems/balance-a-binary-search-tree/description/

```java
ArrayList<Integer> res = new ArrayList<Integer>();

// 有序树转成有序数组
private void travesal(TreeNode cur) {
    if (cur == null) return;
    travesal(cur.left);
    res.add(cur.val);
    travesal(cur.right);
}

// 有序数组转成平衡二叉树
private TreeNode getTree(ArrayList<Integer> nums, int left, int right) {
    if (left > right) return null;
    int mid = left + (right - left) / 2;
    TreeNode root = new TreeNode(nums.get(mid));
    root.left = getTree(nums, left, mid - 1);
    root.right = getTree(nums, mid + 1, right);
    return root;
}

public TreeNode balanceBST(TreeNode root) {
    travesal(root);
    return getTree(res, 0, res.size() - 1);
}
```

### 相同的树 100

https://leetcode.cn/problems/same-tree/

```java
public boolean isSameTree(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null && q != null) {
        return false;
    }
    if (p != null && q == null) {
        return false;
    }
    return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}
```

### 填充每个节点的下一个右侧节点指针 116

https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/

```java
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    Queue<Node> queue = new ArrayDeque<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        Node pre = queue.poll();
        if (pre.left != null) {
            queue.add(pre.left);
        }
        if (pre.right != null) {
            queue.add(pre.right);
        }
        for (int i = 1; i < size; i++) {
            Node cur = queue.poll();
            if (cur.left != null) {
                queue.add(cur.left);
            }
            if (cur.right != null) {
                queue.add(cur.right);
            }
            pre.next = cur;
            pre = cur;
        }
    }
    return root;
}
```

### N皇后II 52

https://leetcode.cn/problems/n-queens-ii/description/

```java
int total = 0;

public int totalNQueens(int n) {
    int row = 0;
    boolean[][] used = new boolean[n][n];
    dfs(row, n, used);
    return total;
}

private void dfs(int row, int n, boolean[][] used) {
    if (row == n) {
        total++;
        return;
    }
    for (int col = 0; col < n; col++) {
        if (check(row, col, used)) {
            used[row][col] = true;
            dfs(row + 1, n, used);
            used[row][col] = false;
        }
    }
}

private boolean check(int row, int col, boolean[][] used) {
    for (int i = 0; i < row; i++) {
        if (used[i][col]) {
            return false;
        }
    }
    int k = 1;
    while (row - k >= 0) {
        if (col + k < used.length && used[row - k][col + k]) {
            return false;
        }
        if (col - k >= 0 && used[row - k][col - k]) {
            return false;
        }
        k++;
    }
    return true;
}
```

### Dota2 参议院 649

https://leetcode.cn/problems/dota2-senate/description/

**尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴！**

```java
public String predictPartyVictory(String senateStr) {
    // R = true表示本轮循环结束后，字符串里依然有R。D同理
    Boolean R = true, D = true;
    // 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R
    int flag = 0;
    byte[] senate =  senateStr.getBytes();
    while (R && D) { // 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了
        R = false;
        D = false;
        for (int i = 0; i < senate.length; i++) {
            if (senate[i] == 'R') {
                if (flag < 0) senate[i] = 0; // 消灭R，R此时为false
                else R = true; // 如果没被消灭，本轮循环结束有R
                flag++;
            }
            if (senate[i] == 'D') {
                if (flag > 0) senate[i] = 0;
                else D = true;
                flag--;
            }
        }
    }
    // 循环结束之后，R和D只能有一个为true
    return R == true ? "Radiant" : "Dire";
}
```

### 分割平衡字符串

https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/

```java
public int balancedStringSplit(String s) {
    int leftCount = 0;
    int rightCount = 0;
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == 'L') {
            leftCount++;
        } else {
            rightCount++;
        }
        if (leftCount == rightCount) {
            sum++;
        }
    }
    return sum;
}
```

### 最长回文子串 5

https://leetcode.cn/problems/longest-palindromic-substring/description/

```java
public String longestPalindrome(String s) {
    int maxLeft = 0;
    int maxRight = 0;
    int maxLength = 1;
    boolean[][] dp = new boolean[s.length()][s.length()];
    for (int i = s.length() - 1; i >= 0; i--) {
        dp[i][i] = true;
        for (int j = i + 1; j < s.length(); j++) {
            if (s.charAt(i) == s.charAt(j)) {
                if (j - i > 1 && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                }
                if (j - i == 1) {
                    dp[i][j] = true;
                }
            }
            if (dp[i][j] && j - i + 1 > maxLength) {
                maxLeft = i;
                maxRight = j;
                maxLength = j - i + 1;
            }
        }
    }
    return s.substring(maxLeft, maxRight + 1);
}
```

### 分割回文串 II 132

https://leetcode.cn/problems/palindrome-partitioning-ii/description/

**回溯**

```java
List<List<String>> lists = new ArrayList<>();
Deque<String> deque = new LinkedList<>();

public List<List<String>> partition(String s) {
    backTracking(s, 0);
    return lists;
}

private void backTracking(String s, int startIndex) {
    //如果起始位置大于s的大小，说明找到了一组分割方案
    if (startIndex >= s.length()) {
        lists.add(new ArrayList(deque));
        return;
    }
    for (int i = startIndex; i < s.length(); i++) {
        //如果是回文子串，则记录
        if (isPalindrome(s, startIndex, i)) {
            String str = s.substring(startIndex, i + 1);
            deque.addLast(str);
        } else {
            continue;
        }
        //起始位置后移，保证不重复
        backTracking(s, i + 1);
        deque.removeLast();
    }
}
//判断是否是回文串
private boolean isPalindrome(String s, int startIndex, int end) {
    for (int i = startIndex, j = end; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
    }
    return true;
}
```

**动态规划**

dp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]。

**dp[i] = min(dp[i], dp[j] + 1);**

```java
public int minCut(String s) {
    if(null == s || "".equals(s)){
        return 0;
    }
    int len = s.length();
    // 1.
    // 记录子串[i..j]是否是回文串
    boolean[][] isPalindromic = new boolean[len][len];
    // 从下到上，从左到右
    for(int i = len - 1; i >= 0; i--){
        for(int j = i; j < len; j++){
            if(s.charAt(i) == s.charAt(j)){
                if(j - i <= 1){
                    isPalindromic[i][j] = true;
                } else{
                    isPalindromic[i][j] = isPalindromic[i + 1][j - 1];
                }
            } else{
                isPalindromic[i][j] = false;
            }
        }
    }

    // 2.
    // dp[i] 表示[0..i]的最小分割次数
    int[] dp = new int[len];
    for(int i = 0; i < len; i++){
        //初始考虑最坏的情况。 1个字符分割0次， len个字符分割 len - 1次
        dp[i] = i;
    }

    for(int i = 1; i < len; i++){
        if(isPalindromic[0][i]){
            // s[0..i]是回文了，那 dp[i] = 0, 一次也不用分割
            dp[i] = 0;
            continue;
        }
        for(int j = 0; j < i; j++){
            // 按文中的思路，不清楚就拿 "ababa" 为例，先写出 isPalindromic 数组，再进行求解
            if(isPalindromic[j + 1][i]){
                dp[i] = Math.min(dp[i], dp[j] + 1);
            }
        }
    }
    return dp[len - 1];
}
```

### 最长递增子序列的个数 673

https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/

dp[i]：i之前（包括i）最长递增子序列的长度为dp[i]

count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]

```java
public int findNumberOfLIS(int[] nums) {
    if (nums.length <= 1) return nums.length;
    int[] dp = new int[nums.length];
    for(int i = 0; i < dp.length; i++) dp[i] = 1;
    int[] count = new int[nums.length];
    for(int i = 0; i < count.length; i++) count[i] = 1;

    int maxCount = 0;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                if (dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    count[i] = count[j];
                } else if (dp[j] + 1 == dp[i]) {
                    count[i] += count[j];
                }
            }
            if (dp[i] > maxCount) maxCount = dp[i];
        } 
    }
    int result = 0;
    for (int i = 0; i < nums.length; i++) {
        if (maxCount == dp[i]) result += count[i];
    }
    return result;
}
```

### 钥匙和房间 841

https://leetcode.cn/problems/keys-and-rooms/description/

```java
public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    boolean[] isVisited = new boolean[rooms.size()];
    dfs(0, rooms, isVisited);
    for (boolean b : isVisited) {
        if (!b) {
            return false;
        }
    }
    return true;
}

private void dfs(int index, List<List<Integer>> rooms, boolean[] isVisited) {
    if (isVisited[index]) {
        return;
    }
    isVisited[index] = true;
    for (int i = 0; i < rooms.get(index).size(); i++) {
        dfs(rooms.get(index).get(i), rooms, isVisited);
    }
}
```

```java
public boolean canVisitAllRooms(List<List<Integer>> rooms) {
    boolean[] isVisited = new boolean[rooms.size()];
    bfs(rooms, isVisited);
    for (boolean b : isVisited) {
        if (!b) {
            return false;
        }
    }
    return true;
}

private void bfs(List<List<Integer>> rooms, boolean[] isVisited) {
    Queue<Integer> queue = new ArrayDeque<>();
    queue.add(0);
    while (!queue.isEmpty()) {
        Integer poll = queue.poll();
        if (isVisited[poll]) {
            continue;
        }
        isVisited[poll] = true;
        for (int i = 0; i < rooms.get(poll).size(); i++) {
            queue.add(rooms.get(poll).get(i));
        }
    }
}
```

### 单词接龙 127

https://leetcode.cn/problems/word-ladder/

**然后就是求起点和终点的最短路径长度，这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径。因为广搜就是以起点中心向四周扩散的搜索。**

dfs超时

```java
int min = Integer.MAX_VALUE;

public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    List<String> isVisited = new ArrayList<>();
    isVisited.add(beginWord);
    dfs(beginWord, endWord, wordList, isVisited);
    return min==Integer.MAX_VALUE ? 0 : min;
}

private void dfs(String beginWord, String endWord, List<String> wordList, List<String> isVisited) {
    if (beginWord.equals(endWord)) {
        min = Math.min(min, isVisited.size());
        return;
    }
    // 相差一位的字符串
    List<String> ladders = getLadder(beginWord, wordList);
    for (int i = 0; i < ladders.size(); i++) {
        if (isVisited.contains(ladders.get(i))) {
            continue;
        }
        isVisited.add(ladders.get(i));
        dfs(ladders.get(i), endWord, wordList, isVisited);
        isVisited.remove(isVisited.size() - 1);
    }
}

private List<String> getLadder(String beginWord, List<String> wordList) {
    List<String> res = new ArrayList<>();
    for (int i = 0; i < wordList.size(); i++) {
        if (check(wordList.get(i), beginWord)) {
            res.add(wordList.get(i));
        }
    }
    return res;
}

private boolean check(String s, String beginWord) {
    int count = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != beginWord.charAt(i)) {
            count++;
        }
    }
    return count == 1;
}
```



```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    HashSet<String> wordSet = new HashSet<>(wordList); //转换为hashset 加快速度
    if (wordSet.size() == 0 || !wordSet.contains(endWord)) {  //特殊情况判断
        return 0;
    }
    Queue<String> queue = new LinkedList<>(); //bfs 队列
    queue.offer(beginWord);
    Map<String, Integer> map = new HashMap<>(); //记录单词对应路径长度
    map.put(beginWord, 1);

    while (!queue.isEmpty()) {
        String word = queue.poll(); //取出队头单词
        int path  = map.get(word); //获取到该单词的路径长度
        for (int i = 0; i < word.length(); i++) { //遍历单词的每个字符
            char[] chars = word.toCharArray(); //将单词转换为char array，方便替换
            for (char k = 'a'; k <= 'z'; k++) { //从'a' 到 'z' 遍历替换
                chars[i] = k; //替换第i个字符
                String newWord = String.valueOf(chars); //得到新的字符串
                if (newWord.equals(endWord)) {  //如果新的字符串值与endWord一致，返回当前长度+1
                    return path + 1;
                }
                if (wordSet.contains(newWord) && !map.containsKey(newWord)) { //如果新单词在set中，但是没有访问过
                    map.put(newWord, path + 1); //记录单词对应的路径长度
                    queue.offer(newWord);//加入队尾
                }
            }
        }
    }
    return 0; //未找到
}
```

### 冗余连接 684

https://leetcode.cn/problems/redundant-connection

```java
int n;
int[] father = new int[1000 + 1];

public void init(int n) {
    this.n = n;
    for (int i = 0; i < father.length; i++) {
        father[i] = i;
    }
}

public int find(int u) {
    if (u == father[u]) {
        return u;
    }
    return father[u] = find(father[u]);
}

public boolean isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 根进行连接 即不能用isSame简写,此时得到的不是u的根而是u本身
public void join(int u, int v) {
    u = find(u);
    v = find(v);
    if (u == v) {
        return;
    }
    father[v] = u;
}

public int[] findRedundantConnection(int[][] edges) {
    int n = edges.length;
    init(n);
    for (int i = 0; i < edges.length; i++) {
        if (isSame(edges[i][0], edges[i][1])) {
            return edges[i];
        }
        join(edges[i][0], edges[i][1]);
    }
    return null;
}
```

### 冗余连接II  685

https://leetcode.cn/problems/redundant-connection-ii/

有向图

```java
private static final int N = 1010;  // 如题：二维数组大小的在3到1000范围内
private int[] father;
public Solution() {
    father = new int[N];

    // 并查集初始化
    for (int i = 0; i < N; ++i) {
        father[i] = i;
    }
}

// 并查集里寻根的过程
private int find(int u) {
    if(u == father[u]) {
        return u;
    }
    father[u] = find(father[u]);
    return father[u];
}

// 将v->u 这条边加入并查集
private void join(int u, int v) {
    u = find(u);
    v = find(v);
    if (u == v) return ;
    father[v] = u;
}

// 判断 u 和 v是否找到同一个根，本题用不上
private Boolean same(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

/**
     * 初始化并查集
     */
private void initFather() {
    // 并查集初始化
    for (int i = 0; i < N; ++i) {
        father[i] = i;
    }
}

/**
     * 在有向图里找到删除的那条边，使其变成树
     * @param edges
     * @return 要删除的边
     */
private int[] getRemoveEdge(int[][] edges) {
    initFather();
    for(int i = 0; i < edges.length; i++) {
        if(same(edges[i][0], edges[i][1])) { // 构成有向环了，就是要删除的边
            return edges[i];
        }
        join(edges[i][0], edges[i][1]);
    }
    return null;
}

/**
     * 删一条边之后判断是不是树
     * @param edges
     * @param deleteEdge 要删除的边
     * @return  true: 是树， false： 不是树
     */
private Boolean isTreeAfterRemoveEdge(int[][] edges, int deleteEdge)
{
    initFather();
    for(int i = 0; i < edges.length; i++)
    {
        if(i == deleteEdge) continue;
        if(same(edges[i][0], edges[i][1])) { // 构成有向环了，一定不是树
            return false;
        }
        join(edges[i][0], edges[i][1]);
    }
    return true;
}

public int[] findRedundantDirectedConnection(int[][] edges) {
    int[] inDegree = new int[N];
    for(int i = 0; i < edges.length; i++)
    {
        // 入度
        inDegree[ edges[i][1] ] += 1;
    }

    // 找入度为2的节点所对应的边，注意要倒序，因为优先返回最后出现在二维数组中的答案
    ArrayList<Integer> twoDegree = new ArrayList<Integer>();
    for(int i = edges.length - 1; i >= 0; i--)
    {
        if(inDegree[edges[i][1]] == 2) {
            twoDegree.add(i);
        }
    }

    // 处理图中情况1 和 情况2
    // 如果有入度为2的节点，那么一定是两条边里删一个，看删哪个可以构成树
    if(!twoDegree.isEmpty())
    {
        if(isTreeAfterRemoveEdge(edges, twoDegree.get(0))) {
            return edges[ twoDegree.get(0)];
        }
        return edges[ twoDegree.get(1)];
    }

    // 明确没有入度为2的情况，那么一定有有向环，找到构成环的边返回就可以了
    return getRemoveEdge(edges);
}
```

### 机器人能否返回原点 657

https://leetcode.cn/problems/robot-return-to-origin/description/

```java
public boolean judgeCircle(String moves) {
    int x = 0;
    int y = 0;
    for (char c : moves.toCharArray()) {
        if (c == 'U') y++;
        if (c == 'D') y--;
        if (c == 'L') x++;
        if (c == 'R') x--;
    }
    return x == 0 && y == 0;
}
```

### 下一个排列  31

https://leetcode.cn/problems/next-permutation/

![下一个排列](../../../.vuepress/public/img\下一个排列.jpg)

```java
public void nextPermutation(int[] nums) {
    for (int i = nums.length - 1; i >= 0; i--) {
        for (int j = nums.length - 1; j > i; j--) {
            if (nums[j] > nums[i]) {
                // 交换
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                // [i + 1, nums.length) 内元素升序排序
                Arrays.sort(nums, i + 1, nums.length);
                return;
            }
        }
    }
    Arrays.sort(nums); // 不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
}
```

### 岛屿的数量 463

https://leetcode.cn/problems/island-perimeter/description/

```java
// 解法一
class Solution {
    // 上下左右 4 个方向
    int[] dirx = {-1, 1, 0, 0};
    int[] diry = {0, 0, -1, 1};

    public int islandPerimeter(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int res = 0; // 岛屿周长
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    for (int k = 0; k < 4; k++) {
                        int x = i + dirx[k];
                        int y = j + diry[k];
                        // 当前位置是陆地，并且从当前位置4个方向扩展的“新位置”是“水域”或“新位置“越界，则会为周长贡献一条边
                        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) {
                            res++;
                            continue;
                        }
                    }
                }
            }
        }
        return res;
    }
}

// 解法二
class Solution {
    public int islandPerimeter(int[][] grid) {
        // 计算岛屿的周长 
        // 方法二 : 遇到相邻的陆地总周长就-2
        int landSum = 0; // 陆地数量 
        int cover = 0; // 相邻陆地数量
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    landSum++;
                    // 统计上面和左边的相邻陆地
                    if(i - 1 >= 0 && grid[i-1][j] == 1) cover++;
                    if(j - 1 >= 0 && grid[i][j-1] == 1) cover++;
                }
            }
        }
        return landSum * 4 - cover * 2;
    }
}
```

### 根据数字二进制下 1 的数目排序

https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/description/

```c++
int bitCount(int n) {
    int count = 0; // 计数器
    while (n > 0) {
        if((n & 1) == 1)  count++;  // 当前位是1，count++
        n >>= 1 ; // n向右移位
    }
    return count;
}

int bitCount(int n) {
    int count = 0;
    while (n) {
        n &= (n - 1); // 清除最低位的1
        count++;
    }
    return count;
}
```

**n &= (n - 1) 将最后一位变成0**

![位运算](../../../.vuepress/public/img\位运算.jpg)

```java
private int cntInt(int val){
    int count = 0;
    while(val > 0) {
        val = val & (val - 1);
        count ++;
    }

    return count;
}

public int[] sortByBits(int[] arr) {
    return Arrays.stream(arr).boxed()
        .sorted(new Comparator<Integer>(){
            @Override
            public int compare(Integer o1, Integer o2) {
                int cnt1 = cntInt(o1);
                int cnt2 = cntInt(o2);
                return (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);
            }
        })
        .mapToInt(Integer::intValue)
        .toArray();
}
```